<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Disney Monopoly</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
        }

        h1, h2, h3 {
            font-family: 'Fredoka One', cursive;
        }

        /* Setup Screen */
        #setup-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        #setup-screen h1 {
            font-size: 3rem;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }

        #setup-screen .subtitle {
            font-size: 1.2rem;
            color: #87CEEB;
            margin-bottom: 40px;
        }

        .setup-container {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 30px;
            max-width: 900px;
            width: 95%;
        }

        .setup-container h2 {
            text-align: center;
            margin-bottom: 20px;
            color: #FFD700;
        }

        .player-count {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
        }

        .player-count button {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid #FFD700;
            background: transparent;
            color: #FFD700;
            font-size: 1.3rem;
            font-family: 'Fredoka One', cursive;
            cursor: pointer;
            transition: all 0.3s;
        }

        .player-count button:hover,
        .player-count button.selected {
            background: #FFD700;
            color: #1a1a2e;
        }

        .player-setup {
            display: none;
            flex-direction: column;
            gap: 15px;
        }

        .player-setup.visible {
            display: flex;
        }

        .player-input {
            display: flex;
            align-items: center;
            gap: 20px;
            background: rgba(255,255,255,0.1);
            padding: 15px 20px;
            border-radius: 15px;
            margin-bottom: 10px;
        }

        .player-input .token {
            font-size: 4rem;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 100px;
        }

        .player-input .token img {
            width: 90px;
            height: 90px;
            object-fit: contain;
            border-radius: 12px;
            filter: drop-shadow(3px 3px 6px rgba(0,0,0,0.4));
        }

        .player-card .token {
            font-size: 2.5rem;
        }

        .player-card .token img {
            width: 3rem;
            height: 3rem;
            object-fit: contain;
        }

        .token-on-board img { width: 2rem; height: 2rem; object-fit: contain; border-radius: 50%; }

        .player-input input {
            flex: 1;
            background: transparent;
            border: none;
            border-bottom: 3px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 1.4rem;
            padding: 10px 5px;
            font-family: 'Nunito', sans-serif;
        }

        .player-input input:focus {
            outline: none;
            border-bottom-color: #FFD700;
        }

        .player-input input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        /* Avatar Selection Gallery */
        .avatar-gallery {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            margin-top: 10px;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
        }

        .avatar-option {
            width: 100%;
            min-width: 80px;
            max-width: 140px;
            aspect-ratio: 1;
            border-radius: 15px;
            border: 3px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.1);
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 8px;
        }

        .avatar-option:hover:not(.taken) {
            border-color: #FFD700;
            transform: scale(1.08);
        }

        .avatar-option.selected {
            border-color: #FFD700;
            background: rgba(255,215,0,0.3);
            box-shadow: 0 0 20px rgba(255,215,0,0.6);
        }

        .avatar-option.taken {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .avatar-option.taken::after {
            content: 'âœ“';
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 1.2rem;
            color: #4CAF50;
        }

        .avatar-option img {
            width: 70%;
            height: auto;
            max-height: 65%;
            object-fit: contain;
        }

        .avatar-option .emoji {
            font-size: 2.8rem;
        }

        .avatar-option .avatar-name {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.9);
            text-align: center;
            margin-top: 5px;
            font-weight: 600;
            line-height: 1.1;
        }

        .player-input-row {
            display: flex;
            flex-direction: column;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
        }

        .player-input-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .player-input-header .player-label {
            color: #FFD700;
            font-family: 'Fredoka One', cursive;
            font-size: 1.3rem;
            min-width: 100px;
        }

        .player-input-header input {
            flex: 1;
            min-width: 150px;
            background: transparent;
            border: none;
            border-bottom: 2px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 1.1rem;
            padding: 8px 5px;
            font-family: 'Nunito', sans-serif;
        }

        .player-input-header input:focus {
            outline: none;
            border-bottom-color: #FFD700;
        }

        .selected-avatar-display {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: rgba(255,215,0,0.25);
            border-radius: 10px;
            border: 2px solid #FFD700;
            min-width: 120px;
            justify-content: center;
        }

        .selected-avatar-display img {
            width: 40px;
            height: 40px;
            object-fit: contain;
        }

        .selected-avatar-display .avatar-name {
            color: white;
            font-weight: 600;
            font-size: 1rem;
        }

        .selected-avatar-display.empty {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.3);
            color: rgba(255,255,255,0.5);
            font-size: 0.85rem;
            font-style: italic;
        }

        .gallery-label {
            color: #87CEEB;
            font-size: 1rem;
            margin-bottom: 8px;
            font-weight: 600;
        }

        #start-game {
            display: none;
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 1.3rem;
            font-family: 'Fredoka One', cursive;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            border: none;
            border-radius: 30px;
            color: #1a1a2e;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #start-game.visible {
            display: block;
        }

        #start-game:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(255,215,0,0.4);
        }

        /* Game Screen */
        #game-screen {
            display: none;
            padding: 10px;
        }

        #game-screen.visible {
            display: block;
        }

        .game-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 20px;
            background: linear-gradient(135deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0.5) 100%);
            border-bottom: 2px solid rgba(255,215,0,0.3);
            gap: 15px;
            flex-wrap: wrap;
        }

        .game-header h1 {
            font-size: 1.2rem;
            color: #FFD700;
            margin: 0;
            white-space: nowrap;
        }

        .header-center {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .header-timer, .header-turn {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(255,255,255,0.1);
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
        }

        .header-timer { display: none; }
        .header-timer.visible { display: flex; }
        .header-turn { display: none; }
        .header-turn.visible { display: flex; }

        .header-timer .timer-icon, .header-turn .turn-icon {
            font-size: 1rem;
        }

        .header-timer .timer-value, .header-turn .turn-value {
            font-family: 'Fredoka One', cursive;
            color: #FFD700;
        }

        .header-timer.warning {
            animation: timerPulse 1s infinite;
            background: rgba(255,100,0,0.3);
        }

        .header-controls {
            display: flex;
            gap: 8px;
        }

        .header-btn {
            width: 38px;
            height: 38px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-btn:hover {
            transform: scale(1.1);
        }

        .header-btn.btn-save { background: linear-gradient(135deg, #4CAF50, #45a049); }
        .header-btn.btn-load { background: linear-gradient(135deg, #2196F3, #1976D2); }
        .header-btn.btn-rules { background: linear-gradient(135deg, #FF9800, #F57C00); }
        .header-btn.btn-music { background: linear-gradient(135deg, #9C27B0, #7B1FA2); }
        .header-btn.btn-music.playing { background: linear-gradient(135deg, #E91E63, #C2185B); box-shadow: 0 0 15px rgba(233, 30, 99, 0.5); }
        .header-btn.btn-load:disabled { opacity: 0.5; cursor: not-allowed; }
        .header-btn.btn-settings { background: linear-gradient(135deg, #607D8B, #455A64); }

        /* Money Bar */
        .money-bar {
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 10px 20px;
            background: linear-gradient(135deg, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0.4) 100%);
            border-radius: 15px;
            margin: 0 auto 10px auto;
            max-width: 1200px;
            flex-wrap: wrap;
        }
        .money-player {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255,255,255,0.95);
            padding: 8px 15px;
            border-radius: 25px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            min-width: 140px;
        }
        .money-player.current {
            transform: scale(1.08);
            box-shadow: 0 4px 15px rgba(255,215,0,0.6);
            border: 3px solid #FFD700;
        }
        .money-player.bankrupt {
            opacity: 0.5;
            filter: grayscale(100%);
        }
        .money-player .token {
            font-size: 1.5rem;
        }
        .money-player .token img {
            width: 1.8rem;
            height: 1.8rem;
            object-fit: contain;
        }
        .money-player .info {
            display: flex;
            flex-direction: column;
        }
        .money-player .name {
            font-size: 0.75rem;
            color: #666;
            font-weight: 600;
        }
        .money-player .amount {
            font-size: 1.1rem;
            font-weight: 800;
            color: #2e7d32;
        }
        .money-player .amount.negative {
            color: #c62828;
        }
        .money-player .monopolies {
            display: flex;
            gap: 4px;
            margin-top: 3px;
        }
        .monopoly-dot {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            border: 2px solid rgba(255,255,255,0.8);
            box-shadow: 0 1px 3px rgba(0,0,0,0.3), inset 0 1px 2px rgba(255,255,255,0.3);
            cursor: help;
            transition: transform 0.2s;
        }
        .monopoly-dot:hover {
            transform: scale(1.3);
        }

        /* Main Game Layout */
        .game-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 10px;
            max-width: 1800px;
            margin: 0 auto;
            min-height: calc(100vh - 80px);
        }

        .game-layout .board-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        .game-layout .players-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-width: 100%;
        }

        @media (max-width: 1000px) {
            .game-layout {
                grid-template-columns: 1fr;
            }
        }

        /* Board */
        .board-container {
            position: relative;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(11, 1fr);
            grid-template-rows: repeat(11, 1fr);
            width: min(45vw, 700px);
            height: min(45vw, 700px);
            background: #c8e6c9;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            border: 3px solid rgba(255,215,0,0.3);
        }

        @media (max-width: 1000px) {
            .board {
                width: min(95vw, 500px);
                height: min(95vw, 500px);
            }
        }

        .square {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 1px solid #666;
            background: #e8f5e9;
            font-size: 1rem;
            padding: 4px;
            position: relative;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            overflow: hidden;
        }

        .square:hover {
            z-index: 10;
            transform: scale(1.15);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .square.monopoly {
            animation: monopolyGlow 2s ease-in-out infinite;
        }
        .square.monopoly::before {
            content: 'ðŸ‘‘';
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 0.7rem;
            z-index: 5;
            filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.5));
        }
        @keyframes monopolyGlow {
            0%, 100% { box-shadow: 0 0 5px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.9), 0 0 25px rgba(255, 215, 0, 0.5); }
        }

        .square .color-bar {
            display: none; /* No longer used - using box-shadow border instead */
        }

        .square .name {
            display: none;
        }

        .square .price {
            display: none;
        }

        .square .icon {
            font-size: 2.2rem;
            margin-top: 0;
        }

        /* Property image support - full square background */
        .square .property-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0;
        }

        /* Ensure other elements appear above image */
        .square .houses,
        .square .owner-indicator,
        .square .icon {
            z-index: 2;
        }

        /* Houses display */
        .square .houses {
            position: absolute;
            bottom: 4px;
            left: 4px;
            display: flex;
            gap: 3px;
        }

        .square .house {
            width: 14px;
            height: 14px;
            background: #4CAF50;
            border-radius: 3px;
        }

        .square .hotel {
            width: 20px;
            height: 16px;
            background: #f44336;
            border-radius: 3px;
        }

        .square.corner {
            background: #fff9c4;
        }

        .square.corner .icon {
            font-size: 2.8rem;
            margin-top: 0;
        }

        .square.corner .name {
            display: none;
        }

        /* Owner indicator */
        .square .owner-indicator {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 0.7rem;
            filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.5));
            background: rgba(255,215,0,0.8);
            border-radius: 50%;
            padding: 2px;
            border: 1px solid #FFD700;
        }
        .square .owner-indicator:empty {
            display: none;
        }
        .square .owner-indicator img {
            width: 1rem !important;
            height: 1rem !important;
        }

        /* Property colors */
        .color-brown { background: #8B4513; }
        .color-lightblue { background: #87CEEB; }
        .color-pink { background: #FF69B4; }
        .color-orange { background: #FFA500; }
        .color-red { background: #FF0000; }
        .color-yellow { background: #FFD700; }
        .color-green { background: #228B22; }
        .color-darkblue { background: #00008B; }

        /* Special squares */
        .square.station {
            background: #f5f5f5;
        }

        .square.utility {
            background: #e1f5fe;
        }

        .square.chance {
            background: #ffecb3;
        }

        .square.chest {
            background: #f3e5f5;
        }

        .square.tax {
            background: #ffcdd2;
        }

        .square.jail {
            background: #ffcc80;
        }

        .square.go-jail {
            background: #ef9a9a;
        }

        .square.parking {
            background: #c8e6c9;
        }

        .square.go {
            background: #b2ff59;
        }

        /* Center area */
        .center {
            grid-column: 2 / 11;
            grid-row: 2 / 11;
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: none;
            padding: 20px;
        }

        .center:hover {
            transform: none;
        }

        .center h2 {
            color: #FFD700;
            font-size: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }

        .center .disney-logo {
            font-size: 4rem;
            margin-bottom: 20px;
        }

        .center-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }

        #build-btn {
            padding: 10px 25px;
            font-size: 1rem;
            font-family: 'Fredoka One', cursive;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border: none;
            border-radius: 20px;
            color: white;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #build-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(76,175,80,0.4);
        }

        #build-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Dice area */
        .dice-container {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
            perspective: 600px;
        }

        .die {
            width: 70px;
            height: 70px;
            background: linear-gradient(145deg, #ffffff, #e6e6e6);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.8rem;
            font-weight: bold;
            color: #1a1a2e;
            box-shadow: 0 6px 15px rgba(0,0,0,0.3), inset 0 2px 4px rgba(255,255,255,0.8);
            transition: transform 0.3s, box-shadow 0.3s;
            transform-style: preserve-3d;
            position: relative;
        }

        .die::before {
            content: '';
            position: absolute;
            inset: -3px;
            border-radius: 15px;
            background: linear-gradient(45deg, #FFD700, #FF6B6B, #4ECDC4, #FFD700);
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .die.rolling {
            animation: roll3D 0.15s infinite linear;
        }

        .die.rolling::before {
            opacity: 1;
            animation: borderGlow 0.5s infinite;
        }

        @keyframes roll3D {
            0% { transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg) scale(1); }
            25% { transform: rotateX(90deg) rotateY(45deg) rotateZ(90deg) scale(1.1); }
            50% { transform: rotateX(180deg) rotateY(90deg) rotateZ(180deg) scale(1); }
            75% { transform: rotateX(270deg) rotateY(135deg) rotateZ(270deg) scale(1.1); }
            100% { transform: rotateX(360deg) rotateY(180deg) rotateZ(360deg) scale(1); }
        }

        @keyframes borderGlow {
            0%, 100% { filter: hue-rotate(0deg) blur(2px); }
            50% { filter: hue-rotate(180deg) blur(4px); }
        }

        .die.landed {
            animation: diceBounce 0.6s cubic-bezier(0.36, 0.07, 0.19, 0.97);
        }

        @keyframes diceBounce {
            0% { transform: translateY(-100px) rotateX(720deg) scale(0.5); opacity: 0; }
            40% { transform: translateY(0) rotateX(0deg) scale(1.2); opacity: 1; }
            55% { transform: translateY(-30px) scale(1); }
            70% { transform: translateY(0) scale(1.1); }
            85% { transform: translateY(-10px) scale(1); }
            100% { transform: translateY(0) scale(1); }
        }

        .die.doubles {
            animation: doublesCelebration 0.8s ease-in-out;
            box-shadow: 0 0 30px #FFD700, 0 0 60px #FFD700;
        }

        @keyframes doublesCelebration {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.2) rotate(-10deg); }
            50% { transform: scale(1.3) rotate(10deg); }
            75% { transform: scale(1.2) rotate(-5deg); }
        }

        /* Confetti container */
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            overflow: hidden;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            opacity: 0;
        }

        .confetti.animate {
            animation: confettiFall 3s ease-out forwards;
        }

        @keyframes confettiFall {
            0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        /* Magic sparkles */
        .sparkle {
            position: absolute;
            pointer-events: none;
            animation: sparkleAnim 0.6s ease-out forwards;
        }

        @keyframes sparkleAnim {
            0% { transform: scale(0) rotate(0deg); opacity: 1; }
            100% { transform: scale(1.5) rotate(180deg); opacity: 0; }
        }

        #roll-dice {
            padding: 18px 50px;
            font-size: 1.5rem;
            font-family: 'Fredoka One', cursive;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            border: none;
            border-radius: 35px;
            color: #1a1a2e;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #roll-dice:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(255,215,0,0.4);
        }

        #roll-dice:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Player tokens on board */
        .tokens-container {
            position: absolute;
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            pointer-events: none;
        }

        .token-on-board {
            font-size: 2.2rem;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.6));
            transition: all 0.5s ease;
            background: white;
            border-radius: 50%;
            padding: 4px;
            border: 2px solid #333;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
        }

        /* Players Panel */
        .players-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 100%;
        }

        /* Player cards container - horizontal layout */
        .player-cards-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
        }

        .player-card {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 15px;
            transition: all 0.3s;
            border: 3px solid transparent;
        }

        .player-card.active {
            border-color: #FFD700;
            border-width: 3px;
            background: rgba(255,215,0,0.2);
            box-shadow: 0 0 20px rgba(255,215,0,0.4);
        }

        .player-card .header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .player-card .token {
            font-size: 2rem;
        }

        .player-card .token img {
            width: 2.2rem;
            height: 2.2rem;
        }

        .player-card .name {
            font-family: 'Fredoka One', cursive;
            font-size: 1.1rem;
        }

        .player-card .turn-indicator {
            display: none;
            margin-left: auto;
            background: #FFD700;
            color: #1a1a2e;
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .player-card.active .turn-indicator {
            display: block;
        }

        .player-card .money {
            font-size: 1.4rem;
            color: #4CAF50;
            font-weight: bold;
        }

        .player-card .money::before {
            content: 'ðŸ’° ';
        }

        .player-card .properties-count {
            font-size: 0.9rem;
            color: #87CEEB;
            margin-top: 8px;
        }

        /* Message area */
        .message-area {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 1rem;
            max-width: 90%;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .message-area.visible {
            opacity: 1;
        }

        /* Square Info Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal {
            background: white;
            border-radius: 20px;
            padding: 25px;
            max-width: 350px;
            width: 90%;
            color: #333;
            text-align: center;
            animation: popIn 0.3s ease;
        }

        .modal.landscape {
            max-width: 700px;
            width: 95%;
        }

        .modal .property-landscape {
            display: flex;
            gap: 25px;
            margin-top: 15px;
        }

        .modal .property-landscape .property-image-side {
            flex: 0 0 250px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .modal .property-landscape .property-image-side img {
            width: 100%;
            max-width: 250px;
            height: auto;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .modal .property-landscape .property-info-side {
            flex: 1;
            text-align: left;
        }

        .modal .property-landscape .property-price {
            font-size: 2.5rem;
            margin: 0 0 15px 0;
            text-align: left;
        }

        .modal .property-landscape .rent-info {
            margin: 0;
        }

        @media (max-width: 600px) {
            .modal.landscape {
                max-width: 95%;
            }
            .modal .property-landscape {
                flex-direction: column;
            }
            .modal .property-landscape .property-image-side {
                flex: none;
            }
            .modal .property-landscape .property-info-side {
                text-align: center;
            }
            .modal .property-landscape .property-price {
                text-align: center;
            }
        }

        @keyframes popIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .modal .property-header {
            padding: 15px;
            border-radius: 10px;
            margin: -25px -25px 20px -25px;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        .modal .property-name {
            font-family: 'Fredoka One', cursive;
            font-size: 1.3rem;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
        }

        .modal .property-movie {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.9);
            margin-top: 5px;
        }

        .modal .property-price {
            font-size: 2rem;
            font-weight: bold;
            color: #4CAF50;
            margin: 15px 0;
        }

        .modal .rent-info {
            text-align: left;
            background: #f5f5f5;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
        }

        .modal .rent-info h4 {
            margin-bottom: 10px;
            color: #666;
        }

        .modal .rent-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #ddd;
        }

        .modal .rent-row:last-child {
            border-bottom: none;
        }

        .modal .property-large-image {
            display: flex;
            justify-content: center;
            margin: 15px 0;
        }

        .modal .property-large-image img {
            width: 100%;
            max-width: 300px;
            height: auto;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        /* Card landscape layout */
        .card-layout {
            display: flex;
            gap: 20px;
            align-items: center;
            padding: 15px;
            background: linear-gradient(135deg, #fafafa 0%, #f0f0f0 100%);
            border-radius: 15px;
            margin: 10px 0;
        }
        .card-layout .card-image {
            flex: 0 0 140px;
        }
        .card-layout .card-image img {
            width: 140px;
            height: 140px;
            object-fit: contain;
            border-radius: 12px;
            filter: drop-shadow(3px 3px 5px rgba(0,0,0,0.2));
        }
        .card-layout .card-text {
            flex: 1;
            font-size: 1.15rem;
            line-height: 1.5;
            color: #333;
            text-align: left;
        }

        /* Player properties modal */
        .player-properties-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
            max-height: 400px;
            overflow-y: auto;
            padding: 10px 0;
        }

        .player-property-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .player-property-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.25);
        }

        .player-property-card .prop-color-bar {
            height: 8px;
        }

        .player-property-card .prop-content {
            padding: 10px;
            text-align: center;
        }

        .player-property-card .prop-icon {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .player-property-card .prop-image {
            width: 100%;
            height: 80px;
            object-fit: cover;
            margin-bottom: 5px;
        }

        .player-property-card .prop-name {
            font-size: 0.75rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .player-property-card .prop-houses {
            font-size: 0.7rem;
            color: #666;
        }

        .player-property-card.mortgaged {
            opacity: 0.6;
            filter: grayscale(50%);
        }

        .player-property-card.mortgaged::after {
            content: 'HIPOTECADA';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-15deg);
            background: rgba(255,0,0,0.8);
            color: white;
            padding: 3px 8px;
            font-size: 0.6rem;
            font-weight: bold;
            border-radius: 3px;
        }

        .player-property-card {
            position: relative;
        }

        .no-properties {
            text-align: center;
            padding: 30px;
            color: #666;
            font-style: italic;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-buttons button {
            flex: 1;
            padding: 12px;
            font-size: 1rem;
            font-family: 'Fredoka One', cursive;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .modal-buttons button:hover {
            transform: scale(1.05);
        }

        .btn-buy {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
        }

        .btn-pass {
            background: #e0e0e0;
            color: #666;
        }

        .btn-close {
            background: linear-gradient(135deg, #2196F3, #1976D2);
            color: white;
        }

        .btn-pay {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            color: white;
        }

        .btn-build {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
        }

        /* Build modal property list */
        .build-properties-list {
            max-height: 300px;
            overflow-y: auto;
            margin: 15px 0;
        }

        .build-property-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            margin: 5px 0;
            background: #f5f5f5;
            border-radius: 8px;
            border-left: 4px solid;
        }

        .build-property-item .info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .build-property-item .houses-display {
            display: flex;
            gap: 2px;
            margin-left: 10px;
        }

        .build-property-item .mini-house {
            width: 10px;
            height: 10px;
            background: #4CAF50;
            border-radius: 2px;
        }

        .build-property-item .mini-hotel {
            width: 14px;
            height: 12px;
            background: #f44336;
            border-radius: 2px;
        }

        .build-property-item button {
            padding: 5px 12px;
            font-size: 0.8rem;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
        }

        .build-property-item .btn-add-house {
            background: #4CAF50;
            color: white;
        }

        .build-property-item .btn-add-house:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Current player highlight */
        .current-turn-banner {
            text-align: center;
            padding: 10px;
            margin-bottom: 10px;
            background: rgba(255,215,0,0.2);
            border-radius: 10px;
        }

        .current-turn-banner .player-name {
            font-family: 'Fredoka One', cursive;
            color: #FFD700;
            font-size: 1.2rem;
        }

        /* Zoom View Panel */
        .zoom-view {
            background: rgba(255,255,255,0.15);
            border-radius: 25px;
            padding: 30px;
            margin-bottom: 25px;
            border: 2px solid rgba(255,215,0,0.3);
        }

        .zoom-view h3 {
            color: #FFD700;
            font-size: 1.8rem;
            margin-bottom: 25px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .zoom-squares {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: stretch;
        }

        .zoom-square {
            flex: 1;
            max-width: 220px;
            min-height: 240px;
            background: #e8f5e9;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
            border: 4px solid #888;
            transition: all 0.3s ease;
        }

        .zoom-square.current {
            transform: scale(1.15);
            border-color: #FFD700;
            border-width: 5px;
            box-shadow: 0 0 35px rgba(255,215,0,0.7);
            z-index: 2;
            min-height: 260px;
            max-width: 240px;
        }

        .zoom-square.adjacent {
            opacity: 0.7;
            transform: scale(0.85);
        }

        .zoom-square .color-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 22%;
            border-radius: 16px 16px 0 0;
        }

        .zoom-square .icon {
            font-size: 4.5rem;
            margin-top: 20px;
        }

        .zoom-square .zoom-image {
            width: 80%;
            max-width: 150px;
            height: auto;
            max-height: 55%;
            object-fit: contain;
            margin-top: 15%;
            border-radius: 10px;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
        }

        .zoom-square.current .zoom-image {
            max-width: 180px;
            max-height: 60%;
        }

        .zoom-square .name {
            font-size: 1.3rem;
            font-weight: bold;
            text-align: center;
            color: #333;
            margin-top: 10px;
            line-height: 1.3;
            padding: 0 5px;
        }

        .zoom-square .price {
            font-size: 1.5rem;
            color: #2e7d32;
            font-weight: 800;
            margin-top: 8px;
        }

        .zoom-square .owner-badge {
            position: absolute;
            top: 8px;
            right: 10px;
            font-size: 1.8rem;
        }

        .zoom-square .player-tokens {
            position: absolute;
            bottom: 12px;
            left: 12px;
            display: flex;
            gap: 6px;
        }

        .zoom-square .player-tokens span {
            font-size: 1.8rem;
            filter: drop-shadow(2px 2px 3px rgba(0,0,0,0.5));
            background: white;
            border-radius: 50%;
            padding: 5px;
            border: 2px solid #333;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-square .player-tokens img {
            width: 1.8rem;
            height: 1.8rem;
            border-radius: 50%;
        }

        .zoom-square.corner {
            background: #fff9c4;
        }

        .zoom-square.station {
            background: #f5f5f5;
        }

        .zoom-square.utility {
            background: #e1f5fe;
        }

        .zoom-square.chance {
            background: #ffecb3;
        }

        .zoom-square.chest {
            background: #f3e5f5;
        }

        .zoom-square.tax {
            background: #ffcdd2;
        }

        .zoom-square.jail {
            background: #ffcc80;
        }

        .zoom-square.go-jail {
            background: #ef9a9a;
        }

        .zoom-square.go {
            background: #b2ff59;
        }

        .zoom-square.parking {
            background: #c8e6c9;
        }

        .zoom-navigation {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }

        /* History & Stats Panel */
        .history-stats-panel {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            margin-top: 15px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .panel-tabs {
            display: flex;
            border-bottom: 2px solid #e0e0e0;
        }
        .panel-tab {
            flex: 1;
            padding: 12px;
            border: none;
            background: #f5f5f5;
            cursor: pointer;
            font-family: 'Fredoka One', cursive;
            font-size: 0.95rem;
            color: #666;
            transition: all 0.3s;
        }
        .panel-tab:hover {
            background: #e8e8e8;
        }
        .panel-tab.active {
            background: white;
            color: #2196F3;
            border-bottom: 3px solid #2196F3;
            margin-bottom: -2px;
        }
        .panel-content {
            max-height: 250px;
            overflow-y: auto;
        }
        .panel-content.hidden {
            display: none;
        }
        .history-list {
            padding: 10px;
        }
        .history-empty {
            text-align: center;
            color: #999;
            padding: 30px;
            font-style: italic;
        }
        .history-entry {
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .history-entry:last-child {
            border-bottom: none;
        }
        .history-entry .time {
            color: #999;
            font-size: 0.75rem;
            min-width: 45px;
        }
        .history-entry .icon {
            font-size: 1.1rem;
        }
        .history-entry .text {
            flex: 1;
            color: #333;
        }
        .history-entry.move { border-left: 3px solid #2196F3; }
        .history-entry.buy { border-left: 3px solid #4CAF50; }
        .history-entry.rent { border-left: 3px solid #FF9800; }
        .history-entry.card { border-left: 3px solid #9C27B0; }
        .history-entry.jail { border-left: 3px solid #f44336; }
        .history-entry.money { border-left: 3px solid #FFD700; }
        .history-entry.build { border-left: 3px solid #795548; }

        .stats-content {
            padding: 15px;
        }
        .stats-section {
            margin-bottom: 15px;
        }
        .stats-section h4 {
            color: #2196F3;
            font-size: 0.9rem;
            margin-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 5px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            font-size: 0.85rem;
        }
        .stat-row .player-name {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .stat-row .value {
            font-weight: bold;
            color: #333;
        }
        .stat-row .value.positive { color: #4CAF50; }
        .stat-row .value.negative { color: #f44336; }
        .stat-bar {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin-top: 3px;
            overflow: hidden;
        }
        .stat-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        /* Responsive adjustments */
        @media (max-width: 1000px) {
            .game-layout {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .board {
                width: min(90vw, 450px);
                height: min(90vw, 450px);
                margin: 0 auto;
            }

            .player-cards-container {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
        }

        @media (max-width: 600px) {
            .board {
                width: 95vw;
                height: 95vw;
            }

            .square .icon {
                font-size: 1.5rem;
            }

            .square.corner .icon {
                font-size: 2rem;
            }

            .center h2 {
                font-size: 0.9rem;
            }

            .center .disney-logo {
                font-size: 1.8rem;
            }

            .die {
                width: 35px;
                height: 35px;
                font-size: 1.2rem;
            }

            #roll-dice {
                padding: 8px 20px;
                font-size: 0.9rem;
            }

            #build-btn {
                padding: 6px 15px;
                font-size: 0.8rem;
            }

            .zoom-view {
                padding: 15px;
            }

            .zoom-view h3 {
                font-size: 1.2rem;
                margin-bottom: 12px;
            }

            .zoom-squares {
                gap: 8px;
            }

            .zoom-square {
                max-width: 120px;
                min-height: 140px;
                padding: 10px;
            }

            .zoom-square.current {
                max-width: 140px;
                min-height: 160px;
            }

            .player-cards-container {
                grid-template-columns: repeat(2, 1fr);
            }

            .player-card {
                padding: 10px;
            }

            .player-card .name {
                font-size: 0.9rem;
            }

            .player-card .money {
                font-size: 1.1rem;
            }

            .zoom-square .icon {
                font-size: 2.8rem;
            }

            .zoom-square .zoom-image {
                max-width: 100px;
                max-height: 50%;
            }

            .zoom-square .name {
                font-size: 1rem;
            }

            .zoom-square .price {
                font-size: 1.1rem;
            }

            .avatar-gallery {
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
            }

            .avatar-option {
                min-width: 60px;
            }

            .avatar-option .avatar-name {
                font-size: 0.65rem;
            }

            .player-input-header {
                flex-direction: column;
                align-items: stretch;
            }

            .selected-avatar-display {
                margin-left: 0;
                margin-top: 10px;
            }
        }

        @media (min-width: 1000px) {
            .board {
                width: 700px;
                height: 700px;
            }

            .square .icon {
                font-size: 2.5rem;
            }

            .square.corner .icon {
                font-size: 3.2rem;
            }
        }

        .music-controls {
            display: none;
            align-items: center;
            gap: 8px;
            background: rgba(156, 39, 176, 0.3);
            padding: 8px 15px;
            border-radius: 20px;
            margin-top: 5px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .music-controls.visible { display: flex; }
        .music-controls .btn-track {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .music-controls .btn-track:hover {
            background: rgba(255,255,255,0.4);
            transform: scale(1.1);
        }
        .music-controls #now-playing {
            color: #FFD700;
            font-size: 0.8rem;
            font-weight: bold;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .music-controls input[type="range"] {
            width: 80px;
            accent-color: #9C27B0;
        }
        .music-controls #volume-label {
            color: white;
            font-size: 0.75rem;
            min-width: 30px;
        }
        .token-on-board.moving { animation: tokenBounce 0.45s cubic-bezier(0.34, 1.56, 0.64, 1); }
        @keyframes tokenBounce {
            0% { transform: scale(1) translateY(0) rotate(0deg); filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.3)); }
            25% { transform: scale(2) translateY(-20px) rotate(-15deg); filter: drop-shadow(4px 10px 8px rgba(0,0,0,0.4)) drop-shadow(0 0 10px gold); }
            50% { transform: scale(2.3) translateY(-28px) rotate(10deg); filter: drop-shadow(6px 15px 10px rgba(0,0,0,0.5)) drop-shadow(0 0 15px gold); }
            75% { transform: scale(1.8) translateY(-12px) rotate(-5deg); filter: drop-shadow(3px 8px 5px rgba(0,0,0,0.35)) drop-shadow(0 0 8px gold); }
            100% { transform: scale(1) translateY(0) rotate(0deg); filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.3)); }
        }
        .token-on-board { transition: all 0.2s ease; font-size: 2.2rem; position: relative; display: flex; align-items: center; justify-content: center; }
        .token-on-board::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            background: radial-gradient(ellipse, rgba(0,0,0,0.3) 0%, transparent 70%);
            border-radius: 50%;
            transition: all 0.3s ease;
        }
        .token-on-board.moving::after {
            width: 30px;
            height: 8px;
        }
        .rules-content { text-align: left; max-height: 60vh; overflow-y: auto; padding: 10px; }
        .rules-content h4 { color: #2196F3; margin: 15px 0 8px 0; font-size: 1rem; }
        .rules-content h4:first-child { margin-top: 0; }
        .rules-content p, .rules-content li { font-size: 0.85rem; line-height: 1.4; color: #555; margin-bottom: 5px; }
        .rules-content ul { margin-left: 20px; margin-bottom: 10px; }
        .jail-options { display: flex; flex-direction: column; gap: 10px; margin: 15px 0; }
        .jail-option { display: flex; align-items: center; padding: 12px 15px; background: #f5f5f5; border-radius: 10px; cursor: pointer; transition: all 0.2s; border: 2px solid transparent; }
        .jail-option:hover { background: #e3f2fd; border-color: #2196F3; }
        .jail-option .option-icon { font-size: 1.5rem; }
        .jail-option .option-text { font-weight: 600; color: #333; flex: 1; margin-left: 10px; }
        .jail-option .option-cost { color: #f44336; font-weight: bold; }
        .save-indicator { position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 10px 20px; border-radius: 20px; font-weight: bold; animation: fadeInOut 2s forwards; z-index: 300; }
        @keyframes fadeInOut { 0% { opacity: 0; transform: translateY(-20px); } 20% { opacity: 1; transform: translateY(0); } 80% { opacity: 1; } 100% { opacity: 0; } }

        /* Game Mode Selection */
        .mode-selection { margin-bottom: 30px; }
        .mode-selection h2 { text-align: center; margin-bottom: 20px; color: #FFD700; }
        .mode-buttons { display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; margin-bottom: 20px; }
        .mode-btn { padding: 20px 30px; border-radius: 15px; border: 3px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.1); color: white; cursor: pointer; transition: all 0.3s; text-align: center; min-width: 150px; }
        .mode-btn:hover { border-color: #FFD700; transform: scale(1.05); }
        .mode-btn.selected { border-color: #FFD700; background: rgba(255,215,0,0.3); box-shadow: 0 0 20px rgba(255,215,0,0.4); }
        .mode-btn .mode-icon { font-size: 2.5rem; margin-bottom: 10px; }
        .mode-btn .mode-name { font-family: 'Fredoka One', cursive; font-size: 1.2rem; }
        .mode-btn .mode-desc { font-size: 0.8rem; color: rgba(255,255,255,0.7); margin-top: 5px; }
        .custom-config { display: none; background: rgba(0,0,0,0.3); border-radius: 15px; padding: 20px; margin-top: 20px; }
        .custom-config.visible { display: block; }
        .custom-config h3 { color: #FFD700; margin-bottom: 15px; text-align: center; }
        .config-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; }
        .config-item { background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; }
        .config-item label { display: block; color: #87CEEB; font-weight: 600; margin-bottom: 8px; font-size: 0.9rem; }
        .config-item input[type="number"], .config-item select { width: 100%; padding: 10px; border: 2px solid rgba(255,255,255,0.3); border-radius: 8px; background: rgba(255,255,255,0.1); color: white; font-size: 1rem; }
        .config-item input[type="number"]:focus, .config-item select:focus { outline: none; border-color: #FFD700; }
        .config-item input[type="range"] { width: 100%; accent-color: #FFD700; }
        .config-item .range-value { text-align: center; color: #FFD700; font-weight: bold; margin-top: 5px; }
        .config-item .toggle-container { display: flex; align-items: center; gap: 10px; }
        .config-item .toggle { position: relative; width: 50px; height: 26px; background: rgba(255,255,255,0.3); border-radius: 13px; cursor: pointer; transition: background 0.3s; }
        .config-item .toggle.active { background: #4CAF50; }
        .config-item .toggle::after { content: ''; position: absolute; top: 3px; left: 3px; width: 20px; height: 20px; background: white; border-radius: 50%; transition: left 0.3s; }
        .config-item .toggle.active::after { left: 27px; }
        .config-item .toggle-label { color: white; }
        .config-item select option { background: #1a1a2e; color: white; }
        @keyframes timerPulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .config-badge { display: inline-flex; align-items: center; gap: 8px; background: rgba(255,215,0,0.2); padding: 5px 12px; border-radius: 15px; font-size: 0.8rem; color: #FFD700; margin: 5px; }
        .config-badges { display: flex; flex-wrap: wrap; justify-content: center; margin-top: 10px; }
    </style>
</head>
<body>
    <!-- Setup Screen -->
    <div id="setup-screen">
        <h1>ðŸ° Disney Monopoly ðŸ°</h1>
        <p class="subtitle">El juego de las peliculas magicas</p>

        <div class="setup-container">
            <!-- Mode Selection -->
            <div class="mode-selection">
                <h2>Escull el mode de joc</h2>
                <div class="mode-buttons">
                    <div class="mode-btn selected" data-mode="classic">
                        <div class="mode-icon">ðŸŽ©</div>
                        <div class="mode-name">Classic</div>
                        <div class="mode-desc">Regles tradicionals</div>
                    </div>
                    <div class="mode-btn" data-mode="quick">
                        <div class="mode-icon">âš¡</div>
                        <div class="mode-name">Rapid</div>
                        <div class="mode-desc">Partida mes curta</div>
                    </div>
                    <div class="mode-btn" data-mode="custom">
                        <div class="mode-icon">âš™ï¸</div>
                        <div class="mode-name">Personalitzat</div>
                        <div class="mode-desc">Configura les opcions</div>
                    </div>
                </div>

                <!-- Custom Config Panel -->
                <div class="custom-config" id="custom-config">
                    <h3>Configuracio Personalitzada</h3>
                    <div class="config-grid">
                        <div class="config-item">
                            <label>Diners inicials</label>
                            <input type="range" id="cfg-money" min="500" max="3000" step="100" value="1500">
                            <div class="range-value" id="cfg-money-value">1500â‚¬</div>
                        </div>
                        <div class="config-item">
                            <label>Bonus per passar SORTIDA</label>
                            <input type="range" id="cfg-go" min="100" max="400" step="50" value="200">
                            <div class="range-value" id="cfg-go-value">200â‚¬</div>
                        </div>
                        <div class="config-item">
                            <label>Limit de torns (0 = sense limit)</label>
                            <input type="range" id="cfg-turns" min="0" max="150" step="10" value="0">
                            <div class="range-value" id="cfg-turns-value">Sense limit</div>
                        </div>
                        <div class="config-item">
                            <label>Limit de temps (minuts, 0 = sense limit)</label>
                            <input type="range" id="cfg-time" min="0" max="90" step="5" value="0">
                            <div class="range-value" id="cfg-time-value">Sense limit</div>
                        </div>
                        <div class="config-item">
                            <label>Propietats inicials per jugador</label>
                            <select id="cfg-initial-props">
                                <option value="0">Cap (regles normals)</option>
                                <option value="2">2 propietats aleatories</option>
                                <option value="3">3 propietats aleatories</option>
                                <option value="4">4 propietats aleatories</option>
                            </select>
                        </div>
                        <div class="config-item">
                            <label>Subhastes</label>
                            <div class="toggle-container">
                                <div class="toggle active" id="cfg-auctions" data-value="true"></div>
                                <span class="toggle-label">Activades</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="config-badges" id="config-summary"></div>
            </div>

            <h2>Â¿Cuantos jugadores?</h2>
            <div class="player-count">
                <button data-count="2">2</button>
                <button data-count="3">3</button>
                <button data-count="4">4</button>
                <button data-count="5">5</button>
                <button data-count="6">6</button>
            </div>

            <div class="player-setup" id="player-setup">
                <!-- Player inputs will be generated here -->
            </div>

            <button id="start-game">Â¡Empezar a Jugar!</button>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="game-screen">
        <div class="game-header">
            <h1>ðŸ° Disney Monopoly</h1>

            <div class="header-center">
                <div class="header-timer" id="header-timer">
                    <span class="timer-icon">â±ï¸</span>
                    <span class="timer-value" id="timer-value">--:--</span>
                </div>
                <div class="header-turn" id="header-turn">
                    <span class="turn-icon">ðŸ”„</span>
                    <span class="turn-value" id="turn-value">0/--</span>
                </div>
            </div>

            <div class="header-controls">
                <button class="header-btn btn-save" id="btn-save" onclick="saveGame()" title="Guardar">ðŸ’¾</button>
                <button class="header-btn btn-load" id="btn-load" onclick="loadGame()" title="Carregar">ðŸ“‚</button>
                <button class="header-btn btn-rules" onclick="showRules()" title="Regles">ðŸ“–</button>
                <button class="header-btn btn-music" id="btn-music" onclick="toggleMusic()" title="MÃºsica">ðŸŽµ</button>
            </div>
        </div>

        <!-- Money Bar -->
        <div class="money-bar" id="money-bar">
            <!-- Player money will be generated here -->
        </div>

        <div class="game-layout">
            <div class="board-container">
                <div class="board" id="board">
                    <!-- Board will be generated by JS -->
                </div>
            </div>

            <div class="players-panel" id="players-panel">
                <!-- Music Controls -->
                <div class="music-controls" id="music-controls">
                    <button class="btn-track" onclick="playPrevTrack()">â®</button>
                    <button class="btn-track" onclick="playNextTrack()">â­</button>
                    <span id="now-playing">-</span>
                    <input type="range" id="volume-slider" min="0" max="100" value="50" onchange="setVolume(this.value)">
                    <span id="volume-label">50%</span>
                </div>

                <!-- Zoom View -->
                <div class="zoom-view" id="zoom-view">
                    <h3>ðŸ” Vista Actual</h3>
                    <div class="zoom-squares" id="zoom-squares">
                        <!-- Zoom squares will be generated here -->
                    </div>
                </div>

                <!-- History & Stats Tabs -->
                <div class="history-stats-panel">
                    <div class="panel-tabs">
                        <button class="panel-tab active" onclick="showPanelTab('history')">ðŸ“œ Historial</button>
                        <button class="panel-tab" onclick="showPanelTab('stats')">ðŸ“Š EstadÃ­stiques</button>
                    </div>
                    <div class="panel-content" id="history-panel">
                        <div class="history-list" id="history-list">
                            <div class="history-empty">La partida encara no ha comenÃ§at...</div>
                        </div>
                    </div>
                    <div class="panel-content hidden" id="stats-panel">
                        <div class="stats-content" id="stats-content">
                            <div class="history-empty">Les estadÃ­stiques apareixeran aquÃ­...</div>
                        </div>
                    </div>
                </div>

                <div class="current-turn-banner">
                    <span>Turno de: </span>
                    <span class="player-name" id="current-player-name">-</span>
                </div>
                <!-- Player cards will be generated here -->
            </div>
        </div>
    </div>

    <!-- Message Area -->
    <div class="message-area" id="message-area"></div>

    <!-- Property Modal -->
    <div class="modal-overlay" id="modal-overlay">
        <div class="modal" id="modal-content">
            <!-- Modal content will be generated dynamically -->
        </div>
    </div>

    <script>
        // ==========================================
        // SOUND SYSTEM
        // ==========================================

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new AudioContext();
            }
        }

        // ==========================================
        // MUSIC SYSTEM (Playlist)
        // ==========================================

        // Afegeix les canÃ§ons aquÃ­ (posa els fitxers a la carpeta audio/)
        const PLAYLIST = [
            { file: 'audio/instrumental1.mp3', title: 'Aventura MÃ gica' },
            { file: 'audio/instrumental2.mp3', title: 'Castell Encantat' },
            { file: 'audio/instrumental3.mp3', title: 'Somnis Disney' },
            { file: 'audio/instrumental4.mp3', title: 'MÃ³n de Fantasia' },
            { file: 'audio/amblletra1.mp3', title: 'CanÃ§Ã³ Disney 1' },
            { file: 'audio/amblletra2.mp3', title: 'CanÃ§Ã³ Disney 2' },
            { file: 'audio/amblletra3.mp3', title: 'CanÃ§Ã³ Disney 3' },
            { file: 'audio/amblletra4.mp3', title: 'CanÃ§Ã³ Disney 4' },
        ];

        let backgroundMusic = null;
        let isMusicPlaying = false;
        let currentTrackIndex = 0;
        let musicVolume = 0.5;
        let shuffledPlaylist = [];

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function initMusic() {
            if (!backgroundMusic) {
                backgroundMusic = new Audio();
                backgroundMusic.volume = musicVolume;
                backgroundMusic.addEventListener('ended', playNextTrack);
                shuffledPlaylist = shuffleArray(PLAYLIST);
            }
        }

        function loadCurrentTrack() {
            if (shuffledPlaylist.length === 0) return false;
            backgroundMusic.src = shuffledPlaylist[currentTrackIndex].file;
            updateNowPlaying();
            return true;
        }

        function updateNowPlaying() {
            const label = document.getElementById('now-playing');
            if (label && shuffledPlaylist.length > 0) {
                label.textContent = shuffledPlaylist[currentTrackIndex].title;
            }
        }

        function playNextTrack() {
            currentTrackIndex = (currentTrackIndex + 1) % shuffledPlaylist.length;
            loadCurrentTrack();
            if (isMusicPlaying) backgroundMusic.play();
        }

        function playPrevTrack() {
            currentTrackIndex = (currentTrackIndex - 1 + shuffledPlaylist.length) % shuffledPlaylist.length;
            loadCurrentTrack();
            if (isMusicPlaying) backgroundMusic.play();
        }

        function toggleMusic() {
            initMusic();
            const btn = document.getElementById('btn-music');
            const controls = document.getElementById('music-controls');

            if (isMusicPlaying) {
                backgroundMusic.pause();
                btn.classList.remove('playing');
                btn.innerHTML = 'ðŸŽµ MÃºsica';
                controls.classList.remove('visible');
                isMusicPlaying = false;
            } else {
                if (!backgroundMusic.src || backgroundMusic.src === location.href) {
                    if (!loadCurrentTrack()) {
                        showMessage('Afegeix canÃ§ons a la carpeta audio/');
                        return;
                    }
                }
                backgroundMusic.play().then(() => {
                    btn.classList.add('playing');
                    btn.innerHTML = 'ðŸŽ¶ Parar';
                    controls.classList.add('visible');
                    isMusicPlaying = true;
                }).catch(err => {
                    showMessage('No s\'ha pogut reproduir. Comprova els fitxers MP3.');
                });
            }
        }

        function setVolume(value) {
            musicVolume = value / 100;
            if (backgroundMusic) backgroundMusic.volume = musicVolume;
            document.getElementById('volume-label').textContent = value + '%';
        }

        function playDiceRoll() {
            initAudio();
            if (!audioCtx) return;

            const now = audioCtx.currentTime;

            // Create realistic dice shaking/tumbling sounds
            // Multiple rapid hits with decreasing intervals (dice bouncing)
            const hitCount = 12;
            for (let i = 0; i < hitCount; i++) {
                // Each hit gets progressively quieter and closer together
                const delay = i * 0.06 + Math.random() * 0.02;
                const volume = 0.15 * (1 - i / hitCount * 0.5);

                // Create noise-like sound for dice hitting surface
                const osc1 = audioCtx.createOscillator();
                const osc2 = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();

                osc1.connect(filter);
                osc2.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);

                // Mix of frequencies for wooden/plastic dice sound
                osc1.frequency.value = 800 + Math.random() * 600;
                osc2.frequency.value = 1200 + Math.random() * 800;
                osc1.type = 'square';
                osc2.type = 'triangle';

                // High-pass filter for clicky sound
                filter.type = 'highpass';
                filter.frequency.value = 500;
                filter.Q.value = 1;

                gain.gain.setValueAtTime(volume, now + delay);
                gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.03);

                osc1.start(now + delay);
                osc1.stop(now + delay + 0.03);
                osc2.start(now + delay);
                osc2.stop(now + delay + 0.03);
            }

            // Add a subtle shake/rattle undertone
            const noiseOsc = audioCtx.createOscillator();
            const noiseGain = audioCtx.createGain();
            const noiseFilter = audioCtx.createBiquadFilter();

            noiseOsc.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);

            noiseOsc.type = 'sawtooth';
            noiseOsc.frequency.value = 100;
            noiseFilter.type = 'bandpass';
            noiseFilter.frequency.value = 2000;
            noiseFilter.Q.value = 0.5;

            noiseGain.gain.setValueAtTime(0.08, now);
            noiseGain.gain.linearRampToValueAtTime(0.02, now + 0.5);
            noiseGain.gain.linearRampToValueAtTime(0, now + 0.7);

            noiseOsc.start(now);
            noiseOsc.stop(now + 0.7);
        }

        function playDiceLand() {
            initAudio();
            if (!audioCtx) return;

            const now = audioCtx.currentTime;

            // Two solid "thunk" sounds for dice landing on table
            for (let i = 0; i < 2; i++) {
                const delay = i * 0.08;

                // Low thump
                const thump = audioCtx.createOscillator();
                const thumpGain = audioCtx.createGain();
                thump.connect(thumpGain);
                thumpGain.connect(audioCtx.destination);
                thump.frequency.setValueAtTime(180 - i * 20, now + delay);
                thump.frequency.exponentialRampToValueAtTime(60, now + delay + 0.1);
                thump.type = 'sine';
                thumpGain.gain.setValueAtTime(0.25, now + delay);
                thumpGain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.12);
                thump.start(now + delay);
                thump.stop(now + delay + 0.12);

                // High click overlay
                const click = audioCtx.createOscillator();
                const clickGain = audioCtx.createGain();
                const clickFilter = audioCtx.createBiquadFilter();
                click.connect(clickFilter);
                clickFilter.connect(clickGain);
                clickGain.connect(audioCtx.destination);
                click.frequency.value = 1500 + Math.random() * 500;
                click.type = 'square';
                clickFilter.type = 'highpass';
                clickFilter.frequency.value = 1000;
                clickGain.gain.setValueAtTime(0.1, now + delay);
                clickGain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.02);
                click.start(now + delay);
                click.stop(now + delay + 0.02);
            }

            // Pleasant success chime
            setTimeout(() => {
                if (!audioCtx) return;
                const notes = [659.25, 783.99]; // E5, G5
                notes.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.frequency.value = freq;
                    osc.type = 'sine';
                    const t = audioCtx.currentTime + i * 0.08;
                    gain.gain.setValueAtTime(0.15, t);
                    gain.gain.linearRampToValueAtTime(0, t + 0.25);
                    osc.start(t);
                    osc.stop(t + 0.25);
                });
            }, 200);
        }

        function playCollectMoney() {
            initAudio();
            if (!audioCtx) return;

            const now = audioCtx.currentTime;
            const notes = [523.25, 659.25, 783.99]; // C5, E5, G5

            notes.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.value = freq;
                osc.type = 'sine';
                gain.gain.setValueAtTime(0.15, now + i * 0.1);
                gain.gain.linearRampToValueAtTime(0, now + i * 0.1 + 0.2);
                osc.start(now + i * 0.1);
                osc.stop(now + i * 0.1 + 0.2);
            });
        }

        function playPayMoney() {
            initAudio();
            if (!audioCtx) return;

            const now = audioCtx.currentTime;
            // Create coin drop sounds - multiple metallic "clinks"
            for (let i = 0; i < 4; i++) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);

                // High metallic frequencies for coin sound
                const baseFreq = 2000 + Math.random() * 1500;
                osc.frequency.setValueAtTime(baseFreq, now + i * 0.08);
                osc.frequency.exponentialRampToValueAtTime(800, now + i * 0.08 + 0.1);
                osc.type = 'square';

                // Bandpass filter for metallic sound
                filter.type = 'bandpass';
                filter.frequency.value = 3000;
                filter.Q.value = 2;

                // Quick attack and decay like a coin hitting surface
                gain.gain.setValueAtTime(0.12, now + i * 0.08);
                gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.08 + 0.12);

                osc.start(now + i * 0.08);
                osc.stop(now + i * 0.08 + 0.15);
            }
        }

        function playCard() {
            initAudio();
            if (!audioCtx) return;

            const now = audioCtx.currentTime;

            // Card flip/swoosh sound
            for (let i = 0; i < 3; i++) {
                const swoosh = audioCtx.createOscillator();
                const swooshGain = audioCtx.createGain();
                const swooshFilter = audioCtx.createBiquadFilter();

                swoosh.connect(swooshFilter);
                swooshFilter.connect(swooshGain);
                swooshGain.connect(audioCtx.destination);

                swoosh.type = 'sawtooth';
                swoosh.frequency.setValueAtTime(100 + i * 50, now + i * 0.02);
                swoosh.frequency.exponentialRampToValueAtTime(2000, now + i * 0.02 + 0.08);

                swooshFilter.type = 'bandpass';
                swooshFilter.frequency.value = 1500;
                swooshFilter.Q.value = 1;

                swooshGain.gain.setValueAtTime(0.08, now + i * 0.02);
                swooshGain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.02 + 0.1);

                swoosh.start(now + i * 0.02);
                swoosh.stop(now + i * 0.02 + 0.1);
            }

            // Paper flick sound
            const flick = audioCtx.createOscillator();
            const flickGain = audioCtx.createGain();
            const flickFilter = audioCtx.createBiquadFilter();

            flick.connect(flickFilter);
            flickFilter.connect(flickGain);
            flickGain.connect(audioCtx.destination);

            flick.type = 'square';
            flick.frequency.value = 3000;
            flickFilter.type = 'highpass';
            flickFilter.frequency.value = 2000;

            flickGain.gain.setValueAtTime(0.06, now + 0.05);
            flickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);

            flick.start(now + 0.05);
            flick.stop(now + 0.1);

            // Magical sparkle chime
            setTimeout(() => {
                if (!audioCtx) return;
                const t = audioCtx.currentTime;
                const sparkleNotes = [1318.51, 1567.98, 2093.00]; // E6, G6, C7

                sparkleNotes.forEach((freq, i) => {
                    const sparkle = audioCtx.createOscillator();
                    const sparkleGain = audioCtx.createGain();

                    sparkle.connect(sparkleGain);
                    sparkleGain.connect(audioCtx.destination);

                    sparkle.frequency.value = freq;
                    sparkle.type = 'sine';

                    sparkleGain.gain.setValueAtTime(0.1, t + i * 0.06);
                    sparkleGain.gain.exponentialRampToValueAtTime(0.001, t + i * 0.06 + 0.2);

                    sparkle.start(t + i * 0.06);
                    sparkle.stop(t + i * 0.06 + 0.2);
                });
            }, 100);
        }

        function playJail() {
            initAudio();
            if (!audioCtx) return;

            const now = audioCtx.currentTime;

            // Metal cell door slam sound
            for (let i = 0; i < 3; i++) {
                const clang = audioCtx.createOscillator();
                const clangGain = audioCtx.createGain();
                const clangFilter = audioCtx.createBiquadFilter();

                clang.connect(clangFilter);
                clangFilter.connect(clangGain);
                clangGain.connect(audioCtx.destination);

                // Metallic frequencies
                clang.frequency.value = 200 + i * 150;
                clang.type = 'square';
                clangFilter.type = 'bandpass';
                clangFilter.frequency.value = 800;
                clangFilter.Q.value = 5;

                clangGain.gain.setValueAtTime(0.2, now);
                clangGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

                clang.start(now);
                clang.stop(now + 0.3);
            }

            // Low rumble for heavy door
            const rumble = audioCtx.createOscillator();
            const rumbleGain = audioCtx.createGain();
            rumble.connect(rumbleGain);
            rumbleGain.connect(audioCtx.destination);
            rumble.frequency.value = 60;
            rumble.type = 'sine';
            rumbleGain.gain.setValueAtTime(0.3, now);
            rumbleGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
            rumble.start(now);
            rumble.stop(now + 0.4);

            // Sad trombone after the slam
            setTimeout(() => {
                if (!audioCtx) return;
                const t = audioCtx.currentTime;
                const notes = [293.66, 277.18, 261.63, 220]; // D4, C#4, C4, A3
                notes.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    const filter = audioCtx.createBiquadFilter();

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(audioCtx.destination);

                    osc.frequency.value = freq;
                    osc.type = 'sawtooth';
                    filter.type = 'lowpass';
                    filter.frequency.value = 1000;

                    gain.gain.setValueAtTime(0.12, t + i * 0.22);
                    gain.gain.linearRampToValueAtTime(0, t + i * 0.22 + 0.28);

                    osc.start(t + i * 0.22);
                    osc.stop(t + i * 0.22 + 0.28);
                });
            }, 350);

            // Chain rattle effect
            setTimeout(() => {
                if (!audioCtx) return;
                const t = audioCtx.currentTime;
                for (let i = 0; i < 6; i++) {
                    const rattle = audioCtx.createOscillator();
                    const rattleGain = audioCtx.createGain();
                    const rattleFilter = audioCtx.createBiquadFilter();

                    rattle.connect(rattleFilter);
                    rattleFilter.connect(rattleGain);
                    rattleGain.connect(audioCtx.destination);

                    rattle.frequency.value = 3000 + Math.random() * 2000;
                    rattle.type = 'square';
                    rattleFilter.type = 'highpass';
                    rattleFilter.frequency.value = 2000;

                    const delay = i * 0.05;
                    rattleGain.gain.setValueAtTime(0.05, t + delay);
                    rattleGain.gain.exponentialRampToValueAtTime(0.001, t + delay + 0.04);

                    rattle.start(t + delay);
                    rattle.stop(t + delay + 0.04);
                }
            }, 200);
        }

        // ==========================================
        // GAME DATA
        // ==========================================

        const TOKENS = [
            { emoji: 'â„ï¸', name: 'Elsa', image: 'images/tokens/elsa.png' },
            { emoji: 'ðŸ¦', name: 'Simba', image: 'images/tokens/simba.png' },
            { emoji: 'ðŸ§œâ€â™€ï¸', name: 'Ariel', image: 'images/tokens/sirenita.png' },
            { emoji: 'ðŸ¤ ', name: 'Woody', image: 'images/tokens/woody.png' },
            { emoji: 'âš”ï¸', name: 'Mulan', image: 'images/tokens/mulan.png' },
            { emoji: 'ðŸŒŠ', name: 'Vaiana', image: 'images/tokens/vaiana.png' },
            { emoji: 'ðŸ§ž', name: 'Genie', image: 'images/tokens/ganie.png' },
            { emoji: 'ðŸ¦¹', name: 'Scar', image: 'images/tokens/scar.png' },
            { emoji: 'ðŸ¤–', name: 'WALL-E', image: 'images/tokens/walle.png' },
            { emoji: 'ðŸŽ¬', name: 'Wachowsky', image: 'images/tokens/wachowsky.png' }
        ];

        // Helper function to render token (image or emoji)
        function renderToken(token, size = '2rem') {
            if (token.image) {
                return `<img src="${token.image}" alt="${token.name}" style="width: ${size}; height: ${size}; object-fit: contain; vertical-align: middle;">`;
            }
            return `<span style="font-size: ${size};">${token.emoji}</span>`;
        }

        function renderTokenSmall(token) {
            return renderToken(token, '2.2rem');
        }

        const PROPERTY_GROUPS = {
            brown: { color: '#8B4513', name: 'Clasicos Antiguos' },
            lightblue: { color: '#87CEEB', name: 'Princesas Clasicas' },
            pink: { color: '#FF69B4', name: 'Princesas Modernas' },
            orange: { color: '#FFA500', name: 'Pixar Clasicos' },
            red: { color: '#FF0000', name: 'Aventuras' },
            yellow: { color: '#FFD700', name: 'Pixar Modernos' },
            green: { color: '#228B22', name: 'Magia y Fantasia' },
            darkblue: { color: '#00008B', name: 'Modernos Premium' }
        };

        // Board squares definition (clockwise from GO)
        const SQUARES = [
            // Bottom row (right to left when looking at board)
            { id: 0, name: 'SALIDA', type: 'go', image: 'images/special/salida.png' },
            { id: 1, name: 'Blancanieves', type: 'property', group: 'brown', price: 60, rent: [2, 10, 30, 90, 160, 250], houseCost: 50, image: 'images/properties/blancanieves.png' },
            { id: 2, name: 'Cofre del Tesoro', type: 'chest', image: 'images/special/cofre.png' },
            { id: 3, name: 'Pinocho', type: 'property', group: 'brown', price: 60, rent: [4, 20, 60, 180, 320, 450], houseCost: 50, image: 'images/properties/pinocho.png' },
            { id: 4, name: 'Impuesto Magico', type: 'tax', amount: 75, image: 'images/special/impuesto.png' },
            { id: 5, name: 'Disneyland', type: 'station', price: 200, image: 'images/stations/disneyland.png' },
            { id: 6, name: 'Cenicienta', type: 'property', group: 'lightblue', price: 100, rent: [6, 30, 90, 270, 400, 550], houseCost: 50, image: 'images/properties/cenicienta.png' },
            { id: 7, name: 'Suerte', type: 'chance', image: 'images/special/suerte.png' },
            { id: 8, name: 'La Bella Durmiente', type: 'property', group: 'lightblue', price: 100, rent: [6, 30, 90, 270, 400, 550], houseCost: 50, image: 'images/properties/belladurmiente.png' },
            { id: 9, name: 'La Bella y la Bestia', type: 'property', group: 'lightblue', price: 120, rent: [8, 40, 100, 300, 450, 600], houseCost: 50, image: 'images/properties/bella_bestia.png' },

            // Left column (bottom to top)
            { id: 10, name: 'CARCEL', type: 'jail', image: 'images/special/carcel.png' },
            { id: 11, name: 'La Sirenita', type: 'property', group: 'pink', price: 140, rent: [10, 50, 150, 450, 625, 750], houseCost: 100, image: 'images/properties/sirenita.png' },
            { id: 12, name: 'Disney+', type: 'utility', price: 150, image: 'images/special/disneyplus.png' },
            { id: 13, name: 'Aladdin', type: 'property', group: 'pink', price: 140, rent: [10, 50, 150, 450, 625, 750], houseCost: 100, image: 'images/properties/aladdin.png' },
            { id: 14, name: 'Pocahontas', type: 'property', group: 'pink', price: 160, rent: [12, 60, 180, 500, 700, 900], houseCost: 100, image: 'images/properties/pocahontas.png' },
            { id: 15, name: 'Disney World', type: 'station', price: 200, image: 'images/stations/disneyworld.png' },
            { id: 16, name: 'Toy Story', type: 'property', group: 'orange', price: 180, rent: [14, 70, 200, 550, 750, 950], houseCost: 100, image: 'images/properties/toystory.png' },
            { id: 17, name: 'Cofre del Tesoro', type: 'chest', image: 'images/special/cofre.png' },
            { id: 18, name: 'Monsters Inc', type: 'property', group: 'orange', price: 180, rent: [14, 70, 200, 550, 750, 950], houseCost: 100, image: 'images/properties/monstruos.png' },
            { id: 19, name: 'Buscando a Nemo', type: 'property', group: 'orange', price: 200, rent: [16, 80, 220, 600, 800, 1000], houseCost: 100, image: 'images/properties/nemo.png' },

            // Top row (left to right)
            { id: 20, name: 'PARKING', type: 'parking', image: 'images/special/parking.png' },
            { id: 21, name: 'El Rey Leon', type: 'property', group: 'red', price: 220, rent: [18, 90, 250, 700, 875, 1050], houseCost: 150, image: 'images/properties/reyleon.png' },
            { id: 22, name: 'Suerte', type: 'chance', image: 'images/special/suerte.png' },
            { id: 23, name: 'Mulan', type: 'property', group: 'red', price: 220, rent: [18, 90, 250, 700, 875, 1050], houseCost: 150, image: 'images/properties/mulan.png' },
            { id: 24, name: 'Hercules', type: 'property', group: 'red', price: 240, rent: [20, 100, 300, 750, 925, 1100], houseCost: 150, image: 'images/properties/hercules.png' },
            { id: 25, name: 'Disneyland Paris', type: 'station', price: 200, image: 'images/stations/disneyland-paris.png' },
            { id: 26, name: 'Los Increibles', type: 'property', group: 'yellow', price: 260, rent: [22, 110, 330, 800, 975, 1150], houseCost: 150, image: 'images/properties/increibles.png' },
            { id: 27, name: 'Up', type: 'property', group: 'yellow', price: 260, rent: [22, 110, 330, 800, 975, 1150], houseCost: 150, image: 'images/properties/up.png' },
            { id: 28, name: 'Disney Channel', type: 'utility', price: 150, image: 'images/special/disneychannel.png' },
            { id: 29, name: 'Coco', type: 'property', group: 'yellow', price: 280, rent: [24, 120, 360, 850, 1025, 1200], houseCost: 150, image: 'images/properties/coco.png' },

            // Right column (top to bottom)
            { id: 30, name: 'IR A CARCEL', type: 'go-jail', image: 'images/special/ir-carcel.png' },
            { id: 31, name: 'Frozen', type: 'property', group: 'green', price: 300, rent: [26, 130, 390, 900, 1100, 1275], houseCost: 200, image: 'images/properties/frozen.png' },
            { id: 32, name: 'Enredados', type: 'property', group: 'green', price: 300, rent: [26, 130, 390, 900, 1100, 1275], houseCost: 200, image: 'images/properties/rapunzel.png' },
            { id: 33, name: 'Cofre del Tesoro', type: 'chest', image: 'images/special/cofre.png' },
            { id: 34, name: 'Moana', type: 'property', group: 'green', price: 320, rent: [28, 150, 450, 1000, 1200, 1400], houseCost: 200, image: 'images/properties/moana.png' },
            { id: 35, name: 'Tokyo Disney', type: 'station', price: 200, image: 'images/stations/tokyo-disney.png' },
            { id: 36, name: 'Suerte', type: 'chance', image: 'images/special/suerte.png' },
            { id: 37, name: 'Encanto', type: 'property', group: 'darkblue', price: 350, rent: [35, 175, 500, 1100, 1300, 1500], houseCost: 200, image: 'images/properties/encanto.png' },
            { id: 38, name: 'Impuesto de Lujo', type: 'tax', amount: 100, image: 'images/special/impuesto-lujo.png' },
            { id: 39, name: 'Raya', type: 'property', group: 'darkblue', price: 400, rent: [50, 200, 600, 1400, 1700, 2000], houseCost: 200, image: 'images/properties/raya.png' }
        ];

        // ==========================================
        // CARDS DATA
        // ==========================================

        const CHANCE_CARDS = [
            { id: 1, text: 'Â¡La magia de Hada Madrina te lleva a la SALIDA!', action: 'goto', destination: 0, collectGo: true },
            { id: 2, text: 'Â¡El Genio te concede un deseo! Cobra 150â‚¬', action: 'collect', amount: 150 },
            { id: 3, text: 'Â¡Simba te invita a las Tierras del Reino! Ve a El Rey Leon', action: 'goto', destination: 21 },
            { id: 4, text: 'Â¡Oh no! La Reina Malvada te envia a la carcel', action: 'jail' },
            { id: 5, text: 'Â¡Woody organiza una fiesta! Cobra 100â‚¬ de cada jugador', action: 'collectFromAll', amount: 100 },
            { id: 6, text: 'Â¡La alfombra magica te lleva a Disneyland!', action: 'goto', destination: 5 },
            { id: 7, text: 'Â¡Elsa congela tus deudas! El banco te paga 200â‚¬', action: 'collect', amount: 200 },
            { id: 8, text: 'Â¡Reparaciones en tu castillo! Paga 25â‚¬ por cada casa y 100â‚¬ por hotel', action: 'repairs', houseCost: 25, hotelCost: 100 },
            { id: 9, text: 'Â¡Mushu te trae buena suerte! Avanza 3 casillas', action: 'move', spaces: 3 },
            { id: 10, text: 'Â¡Rapunzel te presta su pelo! Ve a Enredados', action: 'goto', destination: 32 },
            { id: 11, text: 'Â¡Sebastian encontro un tesoro! Cobra 50â‚¬', action: 'collect', amount: 50 },
            { id: 12, text: 'Â¡Campanilla te hace volar! Ve al Parking Gratuito', action: 'goto', destination: 20 },
            { id: 13, text: 'Â¡Olaf necesita ayuda! Paga 50â‚¬ al banco', action: 'pay', amount: 50 },
            { id: 14, text: 'Â¡Maui te bendice! Cobra 100â‚¬', action: 'collect', amount: 100 },
            { id: 15, text: 'Â¡Retrocede hasta Blancanieves!', action: 'goto', destination: 1 },
            { id: 16, text: 'Â¡El espejo magico te muestra el camino! Avanza hasta la proxima estacion', action: 'nextStation' },
            { id: 17, text: 'ðŸŽ« Â¡La Hada Madrina te protege! Targeta per Sortir de la PresÃ³ Gratis. Guarda-la fins que la necessitis.', action: 'getOutOfJailFree', cardType: 'chance' }
        ];

        const CHEST_CARDS = [
            { id: 1, text: 'Â¡Error del banco a tu favor! Cobra 200â‚¬', action: 'collect', amount: 200 },
            { id: 2, text: 'Â¡Es tu cumpleaÃ±os! Cada jugador te da 25â‚¬', action: 'collectFromAll', amount: 25 },
            { id: 3, text: 'Â¡Herencia del tio Scrooge! Cobra 100â‚¬', action: 'collect', amount: 100 },
            { id: 4, text: 'Â¡Paga la factura del medico! 50â‚¬', action: 'pay', amount: 50 },
            { id: 5, text: 'Â¡Venta de galletas con las princesas! Cobra 50â‚¬', action: 'collect', amount: 50 },
            { id: 6, text: 'Â¡Ve directamente a la SALIDA! Cobra 200â‚¬', action: 'goto', destination: 0, collectGo: true },
            { id: 7, text: 'Â¡Multa por exceso de magia! Paga 20â‚¬', action: 'pay', amount: 20 },
            { id: 8, text: 'Â¡Ganas el concurso de belleza de Agrabah! Cobra 150â‚¬', action: 'collect', amount: 150 },
            { id: 9, text: 'Â¡Dividendos de Disney+! Cobra 75â‚¬', action: 'collect', amount: 75 },
            { id: 10, text: 'Â¡Paga el seguro de tu castillo! 100â‚¬', action: 'pay', amount: 100 },
            { id: 11, text: 'Â¡La abuela Tala te guia! Avanza a Moana', action: 'goto', destination: 34 },
            { id: 12, text: 'Â¡Gastos escolares en la Academia de Princesas! Paga 75â‚¬', action: 'pay', amount: 75 },
            { id: 13, text: 'Â¡Encontraste la lampara! Cobra 100â‚¬', action: 'collect', amount: 100 },
            { id: 14, text: 'Â¡Reparaciones del castillo! Paga 40â‚¬ por casa y 115â‚¬ por hotel', action: 'repairs', houseCost: 40, hotelCost: 115 },
            { id: 15, text: 'Â¡Premio del Festival de las Luces! Cobra 125â‚¬', action: 'collect', amount: 125 },
            { id: 16, text: 'Â¡Te toca ir a la carcel! No pasas por la salida', action: 'jail' },
            { id: 17, text: 'ðŸŽ« Â¡El Genio te concede un deseo! Targeta per Sortir de la PresÃ³ Gratis. Guarda-la fins que la necessitis.', action: 'getOutOfJailFree', cardType: 'chest' }
        ];

        // ==========================================
        // GAME CONFIGURATION SYSTEM
        // ==========================================

        const GAME_MODES = {
            classic: {
                name: 'Classic',
                startingMoney: 1500,
                goReward: 200,
                jailFine: 50,
                maxTurns: 0,  // 0 = unlimited
                timeLimit: 0, // 0 = unlimited (in minutes)
                initialProperties: 0,
                auctionsEnabled: true
            },
            quick: {
                name: 'Rapid',
                startingMoney: 1000,
                goReward: 200,
                jailFine: 50,
                maxTurns: 60,
                timeLimit: 30,
                initialProperties: 2,
                auctionsEnabled: false
            },
            custom: {
                name: 'Personalitzat',
                startingMoney: 1500,
                goReward: 200,
                jailFine: 50,
                maxTurns: 0,
                timeLimit: 0,
                initialProperties: 0,
                auctionsEnabled: true
            }
        };

        let gameConfig = { ...GAME_MODES.classic };
        let selectedGameMode = 'classic';
        let gameTimerInterval = null;
        let gameStartTime = null;

        // ==========================================
        // GAME STATE
        // ==========================================

        let gameState = {
            players: [],
            currentPlayerIndex: 0,
            properties: {}, // squareId -> { owner: playerIndex, houses: 0 }
            chanceDeck: [],
            chestDeck: [],
            started: false,
            diceRolled: false,
            consecutiveDoubles: 0, // Track consecutive doubles for jail rule
            lastRollWasDoubles: false, // Track if last roll was doubles for extra turn
            availableHouses: 32, // Limited houses in the game
            availableHotels: 12, // Limited hotels in the game
            history: [], // Game history log
            gameMode: 'classic',
            gameConfig: null,
            gameStartTime: null,
            stats: {
                turnsPlayed: 0,
                totalMoneyEarned: {},
                totalMoneySpent: {},
                propertiesBought: {},
                rentPaid: {},
                rentReceived: {},
                timesInJail: {},
                doublesRolled: {}
            }
        };

        // ==========================================
        // CARD FUNCTIONS
        // ==========================================

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function initializeDecks() {
            gameState.chanceDeck = shuffleArray(CHANCE_CARDS);
            gameState.chestDeck = shuffleArray(CHEST_CARDS);
        }

        function drawCard(type) {
            const deck = type === 'chance' ? gameState.chanceDeck : gameState.chestDeck;
            const card = deck.shift();
            deck.push(card); // Put card at bottom of deck
            return card;
        }

        // ==========================================
        // SETUP FUNCTIONS
        // ==========================================

        function initSetup() {
            // Mode selection buttons
            const modeButtons = document.querySelectorAll('.mode-btn');
            modeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    modeButtons.forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    selectGameMode(btn.dataset.mode);
                });
            });

            // Custom config sliders
            setupConfigSliders();

            // Toggle for auctions
            const auctionToggle = document.getElementById('cfg-auctions');
            if (auctionToggle) {
                auctionToggle.addEventListener('click', () => {
                    auctionToggle.classList.toggle('active');
                    const isActive = auctionToggle.classList.contains('active');
                    auctionToggle.dataset.value = isActive;
                    auctionToggle.nextElementSibling.textContent = isActive ? 'Activades' : 'Desactivades';
                    updateCustomConfig();
                });
            }

            // Player count buttons
            const countButtons = document.querySelectorAll('.player-count button');
            countButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    countButtons.forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    showPlayerInputs(parseInt(btn.dataset.count));
                });
            });

            document.getElementById('start-game').addEventListener('click', startGame);
        }

        function selectGameMode(mode) {
            selectedGameMode = mode;
            const customConfig = document.getElementById('custom-config');

            if (mode === 'custom') {
                customConfig.classList.add('visible');
                updateCustomConfig();
            } else {
                customConfig.classList.remove('visible');
                gameConfig = { ...GAME_MODES[mode] };
            }
            updateConfigSummary();
        }

        function setupConfigSliders() {
            const moneySlider = document.getElementById('cfg-money');
            const goSlider = document.getElementById('cfg-go');
            const turnsSlider = document.getElementById('cfg-turns');
            const timeSlider = document.getElementById('cfg-time');

            if (moneySlider) {
                moneySlider.addEventListener('input', () => {
                    document.getElementById('cfg-money-value').textContent = moneySlider.value + 'â‚¬';
                    updateCustomConfig();
                });
            }
            if (goSlider) {
                goSlider.addEventListener('input', () => {
                    document.getElementById('cfg-go-value').textContent = goSlider.value + 'â‚¬';
                    updateCustomConfig();
                });
            }
            if (turnsSlider) {
                turnsSlider.addEventListener('input', () => {
                    const val = parseInt(turnsSlider.value);
                    document.getElementById('cfg-turns-value').textContent = val === 0 ? 'Sense limit' : val + ' torns';
                    updateCustomConfig();
                });
            }
            if (timeSlider) {
                timeSlider.addEventListener('input', () => {
                    const val = parseInt(timeSlider.value);
                    document.getElementById('cfg-time-value').textContent = val === 0 ? 'Sense limit' : val + ' minuts';
                    updateCustomConfig();
                });
            }

            // Initial properties select
            const propsSelect = document.getElementById('cfg-initial-props');
            if (propsSelect) {
                propsSelect.addEventListener('change', updateCustomConfig);
            }
        }

        function updateCustomConfig() {
            gameConfig = {
                name: 'Personalitzat',
                startingMoney: parseInt(document.getElementById('cfg-money').value),
                goReward: parseInt(document.getElementById('cfg-go').value),
                jailFine: 50,
                maxTurns: parseInt(document.getElementById('cfg-turns').value),
                timeLimit: parseInt(document.getElementById('cfg-time').value),
                initialProperties: parseInt(document.getElementById('cfg-initial-props').value),
                auctionsEnabled: document.getElementById('cfg-auctions').classList.contains('active')
            };
            updateConfigSummary();
        }

        function updateConfigSummary() {
            const summary = document.getElementById('config-summary');
            if (!summary) return;

            const badges = [];
            badges.push(`<span class="config-badge">ðŸ’° ${gameConfig.startingMoney}â‚¬ inicials</span>`);
            badges.push(`<span class="config-badge">ðŸŽ¯ +${gameConfig.goReward}â‚¬ per GO</span>`);

            if (gameConfig.maxTurns > 0) {
                badges.push(`<span class="config-badge">ðŸ”„ ${gameConfig.maxTurns} torns max</span>`);
            }
            if (gameConfig.timeLimit > 0) {
                badges.push(`<span class="config-badge">â±ï¸ ${gameConfig.timeLimit} min</span>`);
            }
            if (gameConfig.initialProperties > 0) {
                badges.push(`<span class="config-badge">ðŸ  ${gameConfig.initialProperties} prop. inicials</span>`);
            }
            if (!gameConfig.auctionsEnabled) {
                badges.push(`<span class="config-badge">ðŸš« Sense subhastes</span>`);
            }

            summary.innerHTML = badges.join('');
        }

        // Track player avatar selections
        let playerSelections = {};

        function showPlayerInputs(count) {
            const container = document.getElementById('player-setup');
            container.innerHTML = '';
            container.classList.add('visible');

            // Reset player selections
            playerSelections = {};
            for (let i = 0; i < count; i++) {
                playerSelections[i] = null;
            }

            for (let i = 0; i < count; i++) {
                const div = document.createElement('div');
                div.className = 'player-input-row';
                div.innerHTML = `
                    <div class="player-input-header">
                        <span class="player-label">Jugador ${i + 1}</span>
                        <input type="text" placeholder="Nombre del jugador ${i + 1}"
                               value="Jugador ${i + 1}" data-player-index="${i}">
                        <div class="selected-avatar-display empty" id="selected-avatar-${i}">
                            Elige personaje
                        </div>
                    </div>
                    <div class="gallery-label">Elige tu personaje:</div>
                    <div class="avatar-gallery" id="avatar-gallery-${i}">
                        ${TOKENS.map((token, tokenIndex) => `
                            <div class="avatar-option" data-player="${i}" data-token="${tokenIndex}">
                                ${token.image
                                    ? `<img src="${token.image}" alt="${token.name}">`
                                    : `<span class="emoji">${token.emoji}</span>`}
                                <span class="avatar-name">${token.name}</span>
                            </div>
                        `).join('')}
                    </div>
                `;
                container.appendChild(div);
            }

            // Add click handlers for avatar selection
            document.querySelectorAll('.avatar-option').forEach(option => {
                option.addEventListener('click', handleAvatarSelection);
            });

            document.getElementById('start-game').classList.add('visible');
        }

        function handleAvatarSelection(event) {
            const option = event.currentTarget;
            const playerIndex = parseInt(option.dataset.player);
            const tokenIndex = parseInt(option.dataset.token);

            // Check if this token is already taken by another player
            for (const [player, selectedToken] of Object.entries(playerSelections)) {
                if (parseInt(player) !== playerIndex && selectedToken === tokenIndex) {
                    return; // Token is taken
                }
            }

            // Get the previous selection for this player
            const previousSelection = playerSelections[playerIndex];

            // If clicking the same token, deselect it
            if (previousSelection === tokenIndex) {
                playerSelections[playerIndex] = null;
                option.classList.remove('selected');
                updateSelectedAvatarDisplay(playerIndex, null);
                updateTakenAvatars();
                return;
            }

            // Remove previous selection for this player
            if (previousSelection !== null) {
                const prevOption = document.querySelector(
                    `.avatar-option[data-player="${playerIndex}"][data-token="${previousSelection}"]`
                );
                if (prevOption) prevOption.classList.remove('selected');
            }

            // Set new selection
            playerSelections[playerIndex] = tokenIndex;
            option.classList.add('selected');
            updateSelectedAvatarDisplay(playerIndex, tokenIndex);
            updateTakenAvatars();
        }

        function updateSelectedAvatarDisplay(playerIndex, tokenIndex) {
            const display = document.getElementById(`selected-avatar-${playerIndex}`);
            if (tokenIndex === null) {
                display.innerHTML = 'Elige personaje';
                display.classList.add('empty');
            } else {
                const token = TOKENS[tokenIndex];
                display.innerHTML = renderToken(token, '2rem') + ` <span>${token.name}</span>`;
                display.classList.remove('empty');
            }
        }

        function updateTakenAvatars() {
            // Get all taken tokens
            const takenTokens = new Set(
                Object.values(playerSelections).filter(t => t !== null)
            );

            // Update all avatar options across all galleries
            document.querySelectorAll('.avatar-option').forEach(option => {
                const playerIndex = parseInt(option.dataset.player);
                const tokenIndex = parseInt(option.dataset.token);

                // Check if this token is taken by another player
                const isTakenByOther = takenTokens.has(tokenIndex) &&
                                       playerSelections[playerIndex] !== tokenIndex;

                if (isTakenByOther) {
                    option.classList.add('taken');
                } else {
                    option.classList.remove('taken');
                }
            });
        }

        function startGame() {
            const inputs = document.querySelectorAll('.player-input-header input');
            gameState.players = [];

            // Check if all players have selected an avatar
            const playerCount = Object.keys(playerSelections).length;
            for (let i = 0; i < playerCount; i++) {
                if (playerSelections[i] === null) {
                    showMessage(`Â¡El Jugador ${i + 1} necesita elegir un personaje!`);
                    return;
                }
            }

            // Store game configuration
            gameState.gameMode = selectedGameMode;
            gameState.gameConfig = { ...gameConfig };
            gameState.gameStartTime = Date.now();

            inputs.forEach((input, i) => {
                gameState.players.push({
                    name: input.value || `Jugador ${i + 1}`,
                    token: TOKENS[playerSelections[i]],
                    money: gameConfig.startingMoney,
                    position: 0,
                    properties: [],
                    inJail: false,
                    getOutOfJailCards: 0 // Number of "Get Out of Jail Free" cards held
                });
            });

            gameState.started = true;
            gameState.currentPlayerIndex = 0;
            gameState.history = [];

            // Initialize card decks and stats
            initializeDecks();
            initStats();

            document.getElementById('setup-screen').style.display = 'none';
            document.getElementById('game-screen').classList.add('visible');

            createBoard();

            // Distribute initial properties if configured
            if (gameConfig.initialProperties > 0) {
                distributeInitialProperties();
            }

            updatePlayersPanel();
            updateCurrentPlayerDisplay();
            positionAllTokens();
            updateZoomView();

            // Setup game timer and turn counter
            setupGameTimerAndCounter();

            // Add game start to history
            const playerNames = gameState.players.map(p => p.name).join(', ');
            const modeText = gameConfig.name || 'Classic';
            addHistory('move', 'ðŸŽ®', `Partida ${modeText} iniciada amb ${gameState.players.length} jugadors: ${playerNames}`);

            showMessage(`Â¡Empieza ${gameState.players[0].name}! Tira los dados.`);

            // Arrenca la mÃºsica automÃ ticament
            setTimeout(() => toggleMusic(), 500);
        }

        function distributeInitialProperties() {
            // Get all purchasable properties
            const purchasableProps = SQUARES.filter(sq =>
                sq.type === 'property' || sq.type === 'station' || sq.type === 'utility'
            ).map(sq => sq.id);

            // Shuffle properties
            const shuffled = [...purchasableProps].sort(() => Math.random() - 0.5);

            // Distribute to each player
            const propsPerPlayer = gameConfig.initialProperties;
            gameState.players.forEach((player, playerIndex) => {
                for (let i = 0; i < propsPerPlayer && shuffled.length > 0; i++) {
                    const propId = shuffled.shift();
                    const square = SQUARES[propId];

                    // Assign property to player
                    gameState.properties[propId] = {
                        owner: playerIndex,
                        houses: 0
                    };
                    player.properties.push(propId);

                    addHistory('buy', 'ðŸŽ', `${player.name} rep ${square.name} com a propietat inicial`);
                }
            });

            // Update displays
            updateAllSquareDisplays();
        }

        function setupGameTimerAndCounter() {
            // Turn counter
            if (gameConfig.maxTurns > 0) {
                const turnCounter = document.getElementById('header-turn');
                turnCounter.classList.add('visible');
                updateTurnCounter();
            }

            // Game timer
            if (gameConfig.timeLimit > 0) {
                const gameTimer = document.getElementById('header-timer');
                gameTimer.classList.add('visible');
                gameStartTime = Date.now();

                // Clear any existing interval
                if (gameTimerInterval) clearInterval(gameTimerInterval);

                gameTimerInterval = setInterval(updateGameTimer, 1000);
                updateGameTimer();
            }
        }

        function updateTurnCounter() {
            const turnValue = document.getElementById('turn-value');
            if (turnValue && gameConfig.maxTurns > 0) {
                turnValue.textContent = `${gameState.stats.turnsPlayed} / ${gameConfig.maxTurns}`;
            }
        }

        function updateGameTimer() {
            if (!gameConfig.timeLimit || gameConfig.timeLimit === 0) return;

            const elapsed = Date.now() - gameStartTime;
            const remaining = (gameConfig.timeLimit * 60 * 1000) - elapsed;

            const timerValue = document.getElementById('timer-value');
            const gameTimer = document.getElementById('header-timer');

            if (remaining <= 0) {
                timerValue.textContent = '00:00';
                clearInterval(gameTimerInterval);
                endGameByTimeOrTurns();
                return;
            }

            const minutes = Math.floor(remaining / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            timerValue.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

            // Warning animation when less than 5 minutes
            if (remaining < 300000) {
                gameTimer.classList.add('warning');
            }
        }

        function endGameByTimeOrTurns() {
            // Calculate net worth for each player
            const playerWorths = gameState.players.map((player, index) => {
                if (player.bankrupt) return { index, name: player.name, worth: 0, bankrupt: true };

                let worth = player.money;

                // Add property values
                player.properties.forEach(propId => {
                    const square = SQUARES[propId];
                    if (square.price) worth += square.price;

                    // Add house values
                    const propState = gameState.properties[propId];
                    if (propState && propState.houses > 0 && square.houseCost) {
                        worth += propState.houses * square.houseCost;
                    }
                });

                return { index, name: player.name, worth, bankrupt: false };
            });

            // Sort by worth
            playerWorths.sort((a, b) => b.worth - a.worth);

            // Determine winner
            const winner = playerWorths[0];

            // Create results HTML
            let resultsHtml = '<div style="text-align: left; padding: 10px;">';
            resultsHtml += '<h4 style="margin-bottom: 15px;">Classificacio Final:</h4>';
            playerWorths.forEach((p, i) => {
                const medal = i === 0 ? 'ðŸ¥‡' : i === 1 ? 'ðŸ¥ˆ' : i === 2 ? 'ðŸ¥‰' : 'â–ªï¸';
                resultsHtml += `<p style="margin: 5px 0;">${medal} ${p.name}: ${p.worth}â‚¬</p>`;
            });
            resultsHtml += '</div>';

            showModal({
                headerHtml: `
                    <div class="property-header" style="background: linear-gradient(135deg, #FFD700, #FFA500)">
                        <div style="font-size: 3rem">ðŸ†</div>
                        <div class="property-name">Fi de la Partida!</div>
                    </div>
                `,
                bodyHtml: `
                    <p style="font-size: 1.5rem; margin: 20px 0; color: #333;">
                        ${winner.name} guanya amb ${winner.worth}â‚¬!
                    </p>
                    ${resultsHtml}
                `,
                buttons: [{
                    text: 'Nova Partida',
                    class: 'btn-buy',
                    action: () => {
                        location.reload();
                    }
                }]
            });

            // Disable dice
            document.getElementById('roll-dice').disabled = true;
            if (gameTimerInterval) clearInterval(gameTimerInterval);
        }

        // ==========================================
        // BOARD CREATION
        // ==========================================

        function createBoard() {
            const board = document.getElementById('board');
            board.innerHTML = '';

            // Create 11x11 grid
            // Position mapping for squares on the edge
            const positions = getSquarePositions();

            // First create all cells
            for (let row = 0; row < 11; row++) {
                for (let col = 0; col < 11; col++) {
                    const squareIndex = positions[row]?.[col];

                    if (squareIndex !== undefined && squareIndex !== null) {
                        const square = SQUARES[squareIndex];
                        const div = createSquareElement(square, row, col);
                        board.appendChild(div);
                    } else if (row >= 1 && row <= 9 && col >= 1 && col <= 9) {
                        // Center area
                        if (row === 1 && col === 1) {
                            const center = document.createElement('div');
                            center.className = 'square center';
                            center.innerHTML = `
                                <div class="disney-logo">ðŸ°</div>
                                <h2>Disney Monopoly</h2>
                                <div class="dice-container">
                                    <div class="die" id="die1">âš€</div>
                                    <div class="die" id="die2">âš€</div>
                                </div>
                                <button id="roll-dice">ðŸŽ² Tirar Dados</button>
                                <div class="center-buttons">
                                    <button id="build-btn">ðŸ  Construir</button>
                                    <button id="mortgage-btn">ðŸ¦ Hipoteca</button>
                                </div>
                            `;
                            board.appendChild(center);

                            // Add event listeners after element is in DOM
                            setTimeout(() => {
                                document.getElementById('roll-dice').addEventListener('click', rollDice);
                                document.getElementById('build-btn').addEventListener('click', showBuildModal);
                                document.getElementById('mortgage-btn').addEventListener('click', showMortgageModal);
                            }, 0);
                        }
                    }
                }
            }
        }

        function getSquarePositions() {
            // Returns a map of [row][col] -> squareIndex
            // Board is arranged with GO at bottom-right corner
            const positions = {};

            // Bottom row (0-10): squares 0-10 (right to left visually, but we place left to right in grid)
            positions[10] = { 10: 0, 9: 1, 8: 2, 7: 3, 6: 4, 5: 5, 4: 6, 3: 7, 2: 8, 1: 9, 0: 10 };

            // Left column (11-19): squares going up
            positions[9] = { 0: 11 };
            positions[8] = { 0: 12 };
            positions[7] = { 0: 13 };
            positions[6] = { 0: 14 };
            positions[5] = { 0: 15 };
            positions[4] = { 0: 16 };
            positions[3] = { 0: 17 };
            positions[2] = { 0: 18 };
            positions[1] = { 0: 19 };

            // Top row (20-30): left to right
            positions[0] = { 0: 20, 1: 21, 2: 22, 3: 23, 4: 24, 5: 25, 6: 26, 7: 27, 8: 28, 9: 29, 10: 30 };

            // Right column (31-39): going down
            positions[1] = positions[1] || {};
            positions[1][10] = 31;
            positions[2] = positions[2] || {};
            positions[2][10] = 32;
            positions[3] = positions[3] || {};
            positions[3][10] = 33;
            positions[4] = positions[4] || {};
            positions[4][10] = 34;
            positions[5] = positions[5] || {};
            positions[5][10] = 35;
            positions[6] = positions[6] || {};
            positions[6][10] = 36;
            positions[7] = positions[7] || {};
            positions[7][10] = 37;
            positions[8] = positions[8] || {};
            positions[8][10] = 38;
            positions[9] = positions[9] || {};
            positions[9][10] = 39;

            return positions;
        }

        function createSquareElement(square, row, col) {
            const div = document.createElement('div');
            div.className = `square ${square.type}`;
            div.dataset.squareId = square.id;
            div.style.gridRow = row + 1;
            div.style.gridColumn = col + 1;

            // Corner squares
            if ([0, 10, 20, 30].includes(square.id)) {
                div.classList.add('corner');
            }

            let content = '';

            // Color border for properties (instead of color bar)
            if (square.type === 'property' && square.group) {
                const groupColor = PROPERTY_GROUPS[square.group].color;
                div.style.border = `4px solid ${groupColor}`;
            }

            // Check if custom image exists (images/properties/[squareId].png)
            if (square.image) {
                content += `<img class="property-image" src="${square.image}" alt="${square.name}">`;
            } else {
                content += `<span class="icon">${square.icon}</span>`;
            }

            content += `<span class="name">${square.name}</span>`;

            if (square.price) {
                content += `<span class="price">${square.price}â‚¬</span>`;
            }

            // Placeholder for owner indicator
            content += `<span class="owner-indicator" data-owner-indicator="${square.id}"></span>`;

            // Placeholder for houses
            content += `<div class="houses" data-houses="${square.id}"></div>`;

            div.innerHTML = content;

            // Click to show info
            div.addEventListener('click', () => showSquareInfo(square));

            return div;
        }

        function updateSquareDisplay(squareId) {
            const propertyState = gameState.properties[squareId];
            const square = SQUARES[squareId];

            // Update owner indicator
            const ownerIndicator = document.querySelector(`[data-owner-indicator="${squareId}"]`);
            if (ownerIndicator && propertyState) {
                const owner = gameState.players[propertyState.owner];
                ownerIndicator.innerHTML = renderTokenSmall(owner.token);
            }

            // Update houses display
            const housesContainer = document.querySelector(`[data-houses="${squareId}"]`);
            if (housesContainer && propertyState && square.type === 'property') {
                housesContainer.innerHTML = '';
                const houses = propertyState.houses || 0;

                if (houses === 5) {
                    // Hotel
                    housesContainer.innerHTML = '<div class="hotel"></div>';
                } else {
                    for (let i = 0; i < houses; i++) {
                        housesContainer.innerHTML += '<div class="house"></div>';
                    }
                }
            }

            // Update monopoly indicator on board
            const squareEl = getSquareElement(squareId);
            if (squareEl && square.type === 'property' && propertyState) {
                const ownerMonopolies = getPlayerMonopolies(propertyState.owner);
                const isPartOfMonopoly = ownerMonopolies.some(m => m.group === square.group);
                if (isPartOfMonopoly) {
                    squareEl.classList.add('monopoly');
                } else {
                    squareEl.classList.remove('monopoly');
                }
            } else if (squareEl) {
                squareEl.classList.remove('monopoly');
            }
        }

        function updateAllSquareDisplays() {
            Object.keys(gameState.properties).forEach(squareId => {
                updateSquareDisplay(parseInt(squareId));
            });
        }

        // ==========================================
        // ZOOM VIEW
        // ==========================================

        function updateZoomView() {
            const player = gameState.players[gameState.currentPlayerIndex];
            const currentPos = player.position;
            const prevPos = (currentPos - 1 + 40) % 40;
            const nextPos = (currentPos + 1) % 40;

            const positions = [prevPos, currentPos, nextPos];
            const container = document.getElementById('zoom-squares');
            container.innerHTML = '';

            positions.forEach((pos, index) => {
                const square = SQUARES[pos];
                const div = document.createElement('div');

                // Build classes
                let classes = ['zoom-square', square.type];
                if (index === 1) classes.push('current');
                else classes.push('adjacent');
                if ([0, 10, 20, 30].includes(square.id)) classes.push('corner');
                div.className = classes.join(' ');

                let content = '';

                // Color bar for properties
                if (square.type === 'property' && square.group) {
                    content += `<div class="color-bar" style="background: ${PROPERTY_GROUPS[square.group].color}"></div>`;
                }

                // Use image if available, otherwise use icon
                if (square.image) {
                    content += `<img class="zoom-image" src="${square.image}" alt="${square.name}">`;
                } else {
                    content += `<span class="icon">${square.icon}</span>`;
                }
                content += `<span class="name">${square.name}</span>`;

                if (square.price) {
                    content += `<span class="price">${square.price}â‚¬</span>`;
                }

                // Owner badge
                const propState = gameState.properties[square.id];
                if (propState) {
                    const owner = gameState.players[propState.owner];
                    content += `<span class="owner-badge">${renderTokenSmall(owner.token)}</span>`;
                }

                // Players on this square
                const playersHere = gameState.players
                    .filter((p, i) => p.position === pos && !p.bankrupt)
                    .map(p => renderTokenSmall(p.token));

                if (playersHere.length > 0) {
                    content += `<div class="player-tokens">${playersHere.map(e => `<span>${e}</span>`).join('')}</div>`;
                }

                div.innerHTML = content;
                container.appendChild(div);
            });

        }

        // ==========================================
        // TOKEN POSITIONING
        // ==========================================

        function getSquareElement(squareId) {
            return document.querySelector(`[data-square-id="${squareId}"]`);
        }

        function positionAllTokens() {
            // Remove ALL existing tokens (be thorough)
            document.querySelectorAll('.tokens-container').forEach(el => el.remove());
            document.querySelectorAll('.token-on-board').forEach(el => el.remove());

            // Only position tokens for non-bankrupt players
            const activePlayers = gameState.players.filter(p => !p.bankrupt);

            // Group players by position
            const playersByPosition = {};
            gameState.players.forEach((player, index) => {
                if (player.bankrupt) return; // Skip bankrupt players
                if (!playersByPosition[player.position]) {
                    playersByPosition[player.position] = [];
                }
                playersByPosition[player.position].push(index);
            });

            // Place tokens
            for (const [position, playerIndices] of Object.entries(playersByPosition)) {
                const squareEl = getSquareElement(position);
                if (!squareEl) continue;

                const container = document.createElement('div');
                container.className = 'tokens-container';
                container.style.position = 'absolute';
                container.style.bottom = '2px';
                container.style.left = '2px';

                playerIndices.forEach(playerIndex => {
                    const player = gameState.players[playerIndex];
                    const token = document.createElement('span');
                    token.className = 'token-on-board';
                    token.innerHTML = renderTokenSmall(player.token);
                    token.dataset.playerIndex = playerIndex;
                    container.appendChild(token);
                });

                squareEl.style.position = 'relative';
                squareEl.appendChild(container);
            }
        }

        // ==========================================
        // DICE AND MOVEMENT
        // ==========================================

        const DICE_FACES = ['âš€', 'âš', 'âš‚', 'âšƒ', 'âš„', 'âš…'];

        function createConfetti() {
            const container = document.createElement('div');
            container.className = 'confetti-container';
            document.body.appendChild(container);

            const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#9B59B6', '#3498DB', '#E74C3C', '#2ECC71'];
            const emojis = ['âœ¨', 'â­', 'ðŸŒŸ', 'ðŸ’«', 'ðŸŽ‰', 'ðŸŽŠ'];

            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.animationDelay = Math.random() * 0.5 + 's';
                confetti.style.animationDuration = (2 + Math.random() * 2) + 's';

                if (Math.random() > 0.5) {
                    confetti.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                    confetti.style.fontSize = (15 + Math.random() * 15) + 'px';
                } else {
                    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                    confetti.style.width = (8 + Math.random() * 8) + 'px';
                    confetti.style.height = (8 + Math.random() * 8) + 'px';
                }

                container.appendChild(confetti);
                setTimeout(() => confetti.classList.add('animate'), 10);
            }

            setTimeout(() => container.remove(), 4000);
        }

        function createSparkles(element) {
            const rect = element.getBoundingClientRect();
            const sparkles = ['âœ¨', 'â­', 'ðŸ’«', 'ðŸŒŸ'];

            for (let i = 0; i < 8; i++) {
                const sparkle = document.createElement('span');
                sparkle.className = 'sparkle';
                sparkle.textContent = sparkles[Math.floor(Math.random() * sparkles.length)];
                sparkle.style.left = (rect.left + rect.width / 2 + (Math.random() - 0.5) * 100) + 'px';
                sparkle.style.top = (rect.top + rect.height / 2 + (Math.random() - 0.5) * 100) + 'px';
                sparkle.style.fontSize = (20 + Math.random() * 20) + 'px';
                document.body.appendChild(sparkle);
                setTimeout(() => sparkle.remove(), 600);
            }
        }

        function rollDice() {
            if (gameState.diceRolled) return;

            const die1El = document.getElementById('die1');
            const die2El = document.getElementById('die2');
            const rollBtn = document.getElementById('roll-dice');

            rollBtn.disabled = true;

            // Clear previous animation classes
            die1El.classList.remove('landed', 'doubles');
            die2El.classList.remove('landed', 'doubles');

            // Start rolling animation
            die1El.classList.add('rolling');
            die2El.classList.add('rolling');

            // Play rolling sound
            playDiceRoll();

            // Animate dice with random faces
            let rolls = 0;
            const rollInterval = setInterval(() => {
                die1El.textContent = DICE_FACES[Math.floor(Math.random() * 6)];
                die2El.textContent = DICE_FACES[Math.floor(Math.random() * 6)];
                rolls++;

                if (rolls >= 15) {
                    clearInterval(rollInterval);

                    // Final result
                    const dice1 = Math.floor(Math.random() * 6) + 1;
                    const dice2 = Math.floor(Math.random() * 6) + 1;

                    die1El.textContent = DICE_FACES[dice1 - 1];
                    die2El.textContent = DICE_FACES[dice2 - 1];
                    die1El.classList.remove('rolling');
                    die2El.classList.remove('rolling');

                    // Add landing animation
                    die1El.classList.add('landed');
                    setTimeout(() => die2El.classList.add('landed'), 100);

                    // Play dice landing sound
                    playDiceLand();

                    const total = dice1 + dice2;
                    const isDoubles = dice1 === dice2;
                    const player = gameState.players[gameState.currentPlayerIndex];

                    // Track consecutive doubles
                    if (isDoubles) {
                        gameState.consecutiveDoubles++;
                        gameState.lastRollWasDoubles = true;

                        // 3 consecutive doubles = go to jail!
                        if (gameState.consecutiveDoubles >= 3) {
                            setTimeout(() => {
                                die1El.classList.add('doubles');
                                die2El.classList.add('doubles');
                                showMessage(`ðŸš¨ ${player.name} ha tret DOBLES 3 vegades seguides! A LA PRESÃ“! ðŸš¨`);
                            }, 600);
                            addHistory('jail', 'ðŸŽ²', `${player.name} ha tret 3 dobles consecutius i va a la presÃ³!`);
                            gameState.diceRolled = true;
                            gameState.consecutiveDoubles = 0;
                            gameState.lastRollWasDoubles = false;
                            setTimeout(() => {
                                handleGoToJail(player);
                            }, 1500);
                            return;
                        }

                        // Regular doubles - show celebration
                        setTimeout(() => {
                            die1El.classList.add('doubles');
                            die2El.classList.add('doubles');
                            createSparkles(die1El);
                            createSparkles(die2El);
                            createConfetti();
                            const doublesMsg = gameState.consecutiveDoubles === 2
                                ? `ðŸŽ‰ DOBLES x2! ${player.name} ha tret ${dice1} + ${dice2} = ${total}! Compte amb el tercer! ðŸŽ²`
                                : `ðŸŽ‰ DOBLES! ${player.name} ha tret ${dice1} + ${dice2} = ${total}! TornarÃ  a tirar! ðŸŽ²`;
                            showMessage(doublesMsg);
                        }, 600);
                        updateStat('doublesRolled', gameState.currentPlayerIndex, 1);
                        addHistory('move', 'ðŸŽ²', `${player.name} ha tret DOBLES! (${dice1}+${dice2}=${total}) - TornarÃ  a tirar!`);
                    } else {
                        // Not doubles - reset counter
                        gameState.consecutiveDoubles = 0;
                        gameState.lastRollWasDoubles = false;
                        showMessage(`${player.name} ha tret ${dice1} + ${dice2} = ${total}`);
                        addHistory('move', 'ðŸŽ²', `${player.name} ha tret ${dice1}+${dice2}=${total}`);
                    }

                    gameState.diceRolled = true;

                    // Move player after animations complete
                    const moveDelay = isDoubles ? 1500 : 800;
                    setTimeout(() => movePlayer(total), moveDelay);
                }
            }, 80);
        }

        function movePlayer(steps) {
            const player = gameState.players[gameState.currentPlayerIndex];
            const startPosition = player.position;
            const finalPosition = (startPosition + steps) % 40;

            // Animate step by step
            let currentStep = 0;
            const stepDelay = 500; // milÂ·lisegons per casella (mÃ©s lent per fer-ho divertit!)

            function moveOneStep() {
                currentStep++;
                const newPos = (startPosition + currentStep) % 40;
                player.position = newPos;

                // Check if passed GO (position 0)
                if (newPos === 0 && currentStep > 0) {
                    const goReward = gameConfig.goReward;
                    player.money += goReward;
                    updateStat('totalMoneyEarned', gameState.currentPlayerIndex, goReward);
                    addHistory('money', 'ðŸ’°', `${player.name} passa per SORTIDA i cobra ${goReward}â‚¬!`);
                    showMessage(`${player.name} passa per SORTIDA i cobra ${goReward}â‚¬!`);
                    playCollectMoney();
                    updatePlayersPanel();
                }

                // Update visuals
                positionAllTokens();
                animateTokenMove(gameState.currentPlayerIndex);
                if (typeof updateZoomView === 'function') updateZoomView();

                // Continue or finish
                if (currentStep < steps) {
                    setTimeout(moveOneStep, stepDelay);
                } else {
                    // Finished moving - execute square action
                    updatePlayersPanel();
                    setTimeout(() => {
                        executeSquareAction(player, SQUARES[finalPosition]);
                    }, 400);
                }
            }

            // Start the animation
            moveOneStep();
        }

        // ==========================================
        // SQUARE ACTIONS
        // ==========================================

        function executeSquareAction(player, square) {
            switch (square.type) {
                case 'property':
                case 'station':
                case 'utility':
                    handlePropertySquare(player, square);
                    break;
                case 'tax':
                    handleTax(player, square);
                    break;
                case 'go-jail':
                    handleGoToJail(player);
                    break;
                case 'chance':
                    handleCardSquare(player, 'chance');
                    break;
                case 'chest':
                    handleCardSquare(player, 'chest');
                    break;
                case 'jail':
                    if (!player.inJail) {
                        showModal({
                            headerHtml: `
                                <div class="property-header" style="background: #607D8B">
                                    <div style="font-size: 3rem">ðŸ”’</div>
                                    <div class="property-name">Visita a la Carcel</div>
                                </div>
                            `,
                            bodyHtml: `
                                <div class="property-large-image">
                                    <img src="images/special/carcel.png" alt="Carcel">
                                </div>
                                <p style="font-size: 1.3rem; margin: 20px 0; color: #333;">
                                    ${player.name} esta de visita en la carcel. Â¡Solo de paso!
                                </p>
                            `,
                            buttons: [{
                                text: 'Continuar',
                                class: 'btn-close',
                                action: () => {
                                    closeModal();
                                    endTurn();
                                }
                            }]
                        });
                    } else {
                        endTurn();
                    }
                    break;
                case 'parking':
                    showModal({
                        headerHtml: `
                            <div class="property-header" style="background: #4CAF50">
                                <div style="font-size: 3rem">ðŸ…¿ï¸</div>
                                <div class="property-name">Parking Gratuito</div>
                            </div>
                        `,
                        bodyHtml: `
                            <div class="property-large-image">
                                <img src="images/special/parking.png" alt="Parking">
                            </div>
                            <p style="font-size: 1.3rem; margin: 20px 0; color: #333;">
                                ${player.name} descansa en el Parking Gratuito. Â¡Un respiro!
                            </p>
                        `,
                        buttons: [{
                            text: 'Continuar',
                            class: 'btn-close',
                            action: () => {
                                closeModal();
                                endTurn();
                            }
                        }]
                    });
                    break;
                case 'go':
                    showModal({
                        headerHtml: `
                            <div class="property-header" style="background: #E91E63">
                                <div style="font-size: 3rem">ðŸ</div>
                                <div class="property-name">SORTIDA</div>
                            </div>
                        `,
                        bodyHtml: `
                            <div class="property-large-image">
                                <img src="images/special/salida.png" alt="Sortida">
                            </div>
                            <p style="font-size: 1.3rem; margin: 20px 0; color: #333;">
                                ${player.name} esta en la SORTIDA. Â¡Punt de partida!
                            </p>
                        `,
                        buttons: [{
                            text: 'Continuar',
                            class: 'btn-close',
                            action: () => {
                                closeModal();
                                endTurn();
                            }
                        }]
                    });
                    break;
                default:
                    endTurn();
            }
        }

        function handlePropertySquare(player, square) {
            const propertyState = gameState.properties[square.id];

            if (!propertyState) {
                // Property is unowned - offer to buy
                showBuyPropertyModal(player, square);
            } else if (propertyState.owner !== gameState.currentPlayerIndex) {
                // Property owned by someone else - pay rent
                const rent = calculateRent(square, propertyState);
                const owner = gameState.players[propertyState.owner];
                showPayRentModal(player, owner, square, rent);
            } else {
                // Player owns this property
                showMessage(`${player.name} esta en su propiedad: ${square.name}`);
                endTurn();
            }
        }

        // Check if a player owns all properties in a color group
        function ownsFullColorGroup(playerIndex, group) {
            const groupProperties = SQUARES.filter(sq => sq.type === 'property' && sq.group === group);
            return groupProperties.every(sq => {
                const prop = gameState.properties[sq.id];
                return prop && prop.owner === playerIndex;
            });
        }

        function calculateRent(square, propertyState) {
            // No rent on mortgaged properties
            if (propertyState.mortgaged) {
                return 0;
            }

            if (square.type === 'station') {
                // Count stations owned by this player
                const stationsOwned = Object.entries(gameState.properties)
                    .filter(([id, prop]) => prop.owner === propertyState.owner && SQUARES[id].type === 'station')
                    .length;
                return [25, 50, 100, 200][stationsOwned - 1] || 25;
            }

            if (square.type === 'utility') {
                // For now, simplified: 4x or 10x dice roll (we'll use fixed amounts)
                const utilitiesOwned = Object.entries(gameState.properties)
                    .filter(([id, prop]) => prop.owner === propertyState.owner && SQUARES[id].type === 'utility')
                    .length;
                return utilitiesOwned === 2 ? 70 : 28; // Approximation based on average roll of 7
            }

            // Regular property
            const houses = propertyState.houses || 0;
            let rent = square.rent[houses];

            // Double rent if owner has full color set and no houses built yet
            if (houses === 0 && ownsFullColorGroup(propertyState.owner, square.group)) {
                rent *= 2;
            }

            return rent;
        }

        function handleTax(player, square) {
            const imageHtml = square.image ? `<div class="property-large-image"><img src="${square.image}" alt="${square.name}"></div>` : '';

            showModal({
                headerHtml: `
                    <div class="property-header" style="background: #f44336">
                        <div style="font-size: 3rem">${square.icon}</div>
                        <div class="property-name">${square.name}</div>
                    </div>
                `,
                bodyHtml: `
                    ${imageHtml}
                    <p style="font-size: 1.3rem; margin: 20px 0; color: #333;">
                        Debes pagar <strong>${square.amount}â‚¬</strong> de impuestos.
                    </p>
                `,
                buttons: [{
                    text: `Pagar ${square.amount}â‚¬`,
                    class: 'btn-pay',
                    action: () => {
                        player.money -= square.amount;
                        playPayMoney(); // Coin sound
                        updatePlayersPanel();
                        closeModal();
                        showMessage(`${player.name} pago ${square.amount}â‚¬ de impuestos.`);
                        checkBankruptcy(player);
                        endTurn();
                    }
                }]
            });
        }

        function handleGoToJail(player) {
            playJail(); // Play jail sound
            player.position = 10; // Jail position
            player.inJail = true;
            positionAllTokens();

            // Update stats and history
            updateStat('timesInJail', gameState.currentPlayerIndex, 1);
            addHistory('jail', 'ðŸ”’', `${player.name} va a la presÃ³!`);

            showModal({
                headerHtml: `
                    <div class="property-header" style="background: #f44336">
                        <div style="font-size: 3rem">ðŸ‘®</div>
                        <div class="property-name">Â¡A la Carcel!</div>
                    </div>
                `,
                bodyHtml: `
                    <div class="property-large-image">
                        <img src="images/special/ir-carcel.png" alt="Ir a la Carcel">
                    </div>
                    <p style="font-size: 1.3rem; margin: 20px 0; color: #333;">
                        ${player.name} va a la carcel. PerderÃ¡s el prÃ³ximo turno.
                    </p>
                `,
                buttons: [{
                    text: 'Entendido',
                    class: 'btn-close',
                    action: () => {
                        closeModal();
                        endTurn();
                    }
                }]
            });
        }

        function handleCardSquare(player, cardType) {
            playCard(); // Play card sound
            const card = drawCard(cardType);
            const isChance = cardType === 'chance';
            const cardTitle = isChance ? 'ðŸŽ² Suerte' : 'ðŸ“¦ Cofre del Tesoro';
            const cardColor = isChance ? '#FF9800' : '#9C27B0';
            const cardImage = isChance ? 'images/special/suerte.png' : 'images/special/cofre.png';
            const cardIcon = isChance ? 'ðŸŽ²' : 'ðŸ“¦';

            // Add to history
            const cardTypeText = isChance ? 'Suerte' : 'Cofre';
            addHistory('card', cardIcon, `${player.name} treu carta de ${cardTypeText}: "${card.text}"`);

            showModal({
                headerHtml: `
                    <div class="property-header" style="background: ${cardColor}">
                        <div style="font-size: 2.5rem">${cardIcon}</div>
                        <div class="property-name">${cardTitle}</div>
                    </div>
                `,
                bodyHtml: `
                    <div class="card-layout">
                        <div class="card-image">
                            <img src="${cardImage}" alt="${cardTitle}">
                        </div>
                        <div class="card-text">
                            ${card.text}
                        </div>
                    </div>
                `,
                buttons: [{
                    text: 'Continuar',
                    class: 'btn-close',
                    action: () => {
                        closeModal();
                        executeCardAction(player, card);
                    }
                }]
            });
        }

        function executeCardAction(player, card) {
            switch (card.action) {
                case 'collect':
                    player.money += card.amount;
                    showMessage(`${player.name} cobra ${card.amount}â‚¬`);
                    updatePlayersPanel();
                    endTurn();
                    break;

                case 'pay':
                    player.money -= card.amount;
                    playPayMoney(); // Coin sound
                    showMessage(`${player.name} paga ${card.amount}â‚¬`);
                    updatePlayersPanel();
                    checkBankruptcy(player);
                    endTurn();
                    break;

                case 'goto':
                    const oldPos = player.position;
                    player.position = card.destination;

                    // Check if passed GO (only if moving forward and collectGo is true)
                    if (card.collectGo && card.destination <= oldPos) {
                        const goReward = gameConfig.goReward;
                        player.money += goReward;
                        updateStat('totalMoneyEarned', gameState.currentPlayerIndex, goReward);
                        addHistory('money', 'ðŸ’°', `${player.name} passa per SORTIDA i cobra ${goReward}â‚¬!`);
                        showMessage(`${player.name} pasa por SALIDA y cobra ${goReward}â‚¬`);
                    }

                    positionAllTokens();
                    updatePlayersPanel();
                    updateZoomView();

                    // Execute action on new square (but not if it's GO itself)
                    if (card.destination !== 0) {
                        setTimeout(() => {
                            executeSquareAction(player, SQUARES[card.destination]);
                        }, 500);
                    } else {
                        endTurn();
                    }
                    break;

                case 'move':
                    const newPos = (player.position + card.spaces) % 40;
                    if (newPos < player.position && card.spaces > 0) {
                        const goReward = gameConfig.goReward;
                        player.money += goReward;
                        updateStat('totalMoneyEarned', gameState.currentPlayerIndex, goReward);
                        addHistory('money', 'ðŸ’°', `${player.name} passa per SORTIDA i cobra ${goReward}â‚¬!`);
                        showMessage(`${player.name} pasa por SALIDA y cobra ${goReward}â‚¬`);
                    }
                    player.position = newPos;
                    positionAllTokens();
                    updatePlayersPanel();
                    updateZoomView();
                    setTimeout(() => {
                        executeSquareAction(player, SQUARES[newPos]);
                    }, 500);
                    break;

                case 'jail':
                    handleGoToJail(player);
                    break;

                case 'getOutOfJailFree':
                    player.getOutOfJailCards++;
                    showMessage(`ðŸŽ« ${player.name} guarda una Targeta per Sortir de la PresÃ³ Gratis!`);
                    addHistory('card', 'ðŸŽ«', `${player.name} ha obtingut una targeta per sortir de la presÃ³ gratis!`);
                    endTurn();
                    break;

                case 'collectFromAll':
                    let totalCollected = 0;
                    gameState.players.forEach((p, i) => {
                        if (i !== gameState.currentPlayerIndex && !p.bankrupt) {
                            p.money -= card.amount;
                            totalCollected += card.amount;
                        }
                    });
                    if (totalCollected > 0) playPayMoney(); // Coin sound
                    player.money += totalCollected;
                    showMessage(`${player.name} cobra ${totalCollected}â‚¬ de los otros jugadores`);
                    updatePlayersPanel();
                    endTurn();
                    break;

                case 'repairs':
                    let totalCost = 0;
                    player.properties.forEach(propId => {
                        const propState = gameState.properties[propId];
                        const square = SQUARES[propId];
                        if (square.type === 'property' && propState) {
                            const houses = propState.houses || 0;
                            if (houses === 5) {
                                totalCost += card.hotelCost;
                            } else {
                                totalCost += houses * card.houseCost;
                            }
                        }
                    });
                    player.money -= totalCost;
                    if (totalCost > 0) playPayMoney(); // Coin sound
                    showMessage(`${player.name} paga ${totalCost}â‚¬ en reparaciones`);
                    updatePlayersPanel();
                    checkBankruptcy(player);
                    endTurn();
                    break;

                case 'nextStation':
                    // Find next station from current position
                    const stations = [5, 15, 25, 35];
                    let nextStation = stations.find(s => s > player.position);
                    if (!nextStation) nextStation = stations[0]; // Wrap around

                    // Check if passing GO
                    if (nextStation < player.position) {
                        const goReward = gameConfig.goReward;
                        player.money += goReward;
                        updateStat('totalMoneyEarned', gameState.currentPlayerIndex, goReward);
                        addHistory('money', 'ðŸ’°', `${player.name} passa per SORTIDA i cobra ${goReward}â‚¬!`);
                        showMessage(`${player.name} pasa por SALIDA y cobra ${goReward}â‚¬`);
                    }

                    player.position = nextStation;
                    positionAllTokens();
                    updatePlayersPanel();
                    updateZoomView();
                    setTimeout(() => {
                        executeSquareAction(player, SQUARES[nextStation]);
                    }, 500);
                    break;

                default:
                    endTurn();
            }
        }

        // ==========================================
        // MODALS
        // ==========================================

        function showBuyPropertyModal(player, square) {
            const groupInfo = square.group ? PROPERTY_GROUPS[square.group] : null;
            const color = groupInfo?.color || '#2196F3';

            let rentHtml = '';
            if (square.rent) {
                rentHtml = `
                    <div class="rent-info">
                        <h4>Alquileres:</h4>
                        <div class="rent-row"><span>Sin casas:</span><span>${square.rent[0]}â‚¬</span></div>
                        <div class="rent-row"><span>1 casa:</span><span>${square.rent[1]}â‚¬</span></div>
                        <div class="rent-row"><span>2 casas:</span><span>${square.rent[2]}â‚¬</span></div>
                        <div class="rent-row"><span>3 casas:</span><span>${square.rent[3]}â‚¬</span></div>
                        <div class="rent-row"><span>4 casas:</span><span>${square.rent[4]}â‚¬</span></div>
                        <div class="rent-row"><span>Hotel:</span><span>${square.rent[5]}â‚¬</span></div>
                    </div>
                `;
            }

            const canAfford = player.money >= square.price;
            const hasImage = square.image;

            let bodyContent = '';
            if (hasImage) {
                bodyContent = `
                    <div class="property-landscape">
                        <div class="property-image-side">
                            <img src="${square.image}" alt="${square.name}">
                        </div>
                        <div class="property-info-side">
                            <div class="property-price">${square.price}â‚¬</div>
                            ${rentHtml}
                            ${!canAfford ? '<p style="color: #f44336; margin-top: 10px;">No tienes suficiente dinero.</p>' : ''}
                        </div>
                    </div>
                `;
            } else {
                bodyContent = `
                    <div class="property-price">${square.price}â‚¬</div>
                    ${rentHtml}
                    ${!canAfford ? '<p style="color: #f44336;">No tienes suficiente dinero.</p>' : ''}
                `;
            }

            showModal({
                headerHtml: `
                    <div class="property-header" style="background: ${color}">
                        <div style="font-size: 2rem">${square.icon}</div>
                        <div class="property-name">${square.name}</div>
                        ${groupInfo ? `<div class="property-movie">${groupInfo.name}</div>` : ''}
                    </div>
                `,
                bodyHtml: bodyContent,
                landscape: hasImage,
                buttons: canAfford ? [
                    {
                        text: `Comprar por ${square.price}â‚¬`,
                        class: 'btn-buy',
                        action: () => buyProperty(player, square)
                    },
                    {
                        text: 'ðŸ”¨ Subhasta',
                        class: 'btn-pass',
                        action: () => {
                            closeModal();
                            startAuction(square);
                        }
                    }
                ] : [
                    {
                        text: 'ðŸ”¨ Subhasta',
                        class: 'btn-close',
                        action: () => {
                            closeModal();
                            startAuction(square);
                        }
                    }
                ]
            });
        }

        // ==========================================
        // AUCTION SYSTEM
        // ==========================================

        function startAuction(square) {
            const auctionState = {
                square: square,
                currentBid: 0,
                highestBidder: null,
                currentBidderIndex: 0,
                passedPlayers: new Set()
            };
            showAuctionModal(auctionState);
        }

        function showAuctionModal(auctionState) {
            const { square, currentBid, highestBidder, passedPlayers } = auctionState;
            let { currentBidderIndex } = auctionState;
            const groupInfo = square.group ? PROPERTY_GROUPS[square.group] : null;
            const color = groupInfo?.color || '#2196F3';

            // Find next active bidder
            let attempts = 0;
            while ((passedPlayers.has(currentBidderIndex) || gameState.players[currentBidderIndex].bankrupt) && attempts < gameState.players.length) {
                currentBidderIndex = (currentBidderIndex + 1) % gameState.players.length;
                attempts++;
            }
            auctionState.currentBidderIndex = currentBidderIndex;

            // Check if auction is over
            const activeBidders = gameState.players.filter((p, i) => !p.bankrupt && !passedPlayers.has(i));
            if (activeBidders.length <= 1 || attempts >= gameState.players.length) {
                closeModal();
                if (highestBidder !== null && currentBid > 0) {
                    const winner = gameState.players[highestBidder];
                    winner.money -= currentBid;
                    winner.properties.push(square.id);
                    gameState.properties[square.id] = { owner: highestBidder, houses: 0 };
                    updatePlayersPanel();
                    updateSquareDisplay(square.id);
                    addHistory('auction', 'ðŸ”¨', `${winner.name} guanya la subhasta de ${square.name} per ${currentBid}â‚¬!`);
                    showMessage(`ðŸ”¨ ${winner.name} guanya ${square.name} per ${currentBid}â‚¬!`);
                } else {
                    showMessage(`La subhasta de ${square.name} ha quedat deserta.`);
                }
                endTurn();
                return;
            }

            const currentBidder = gameState.players[currentBidderIndex];
            const minBid = currentBid + 10;
            const canBid = currentBidder.money >= minBid;

            let biddersHtml = '<div style="margin: 10px 0; text-align: center;">';
            gameState.players.forEach((p, i) => {
                if (!p.bankrupt) {
                    const status = passedPlayers.has(i) ? 'âŒ' : (i === highestBidder ? 'ðŸ‘‘' : '');
                    const isCurrent = i === currentBidderIndex;
                    biddersHtml += `<span style="display: inline-block; padding: 3px 8px; margin: 2px; background: ${isCurrent ? '#FFD700' : '#eee'}; border-radius: 10px; ${passedPlayers.has(i) ? 'opacity: 0.5;' : ''}">${status}${p.name}</span>`;
                }
            });
            biddersHtml += '</div>';

            showModal({
                headerHtml: `<div class="property-header" style="background: ${color}"><div style="font-size: 2rem">ðŸ”¨</div><div class="property-name">Subhasta: ${square.name}</div></div>`,
                bodyHtml: `
                    <div style="text-align: center; margin: 10px 0;">
                        <div style="font-size: 1.5rem; color: #E91E63;">Puja: <strong>${currentBid > 0 ? currentBid + 'â‚¬' : '0â‚¬'}</strong></div>
                        ${highestBidder !== null ? `<div style="color: #4CAF50;">LÃ­der: ${gameState.players[highestBidder].name}</div>` : ''}
                    </div>
                    ${biddersHtml}
                    <div style="text-align: center; margin: 10px 0; padding: 10px; background: #FFF3E0; border-radius: 5px;">
                        <strong style="color: #FF9800;">Torn: ${currentBidder.name}</strong> (${currentBidder.money}â‚¬)
                    </div>
                `,
                buttons: []
            });

            setTimeout(() => {
                const modalContent = document.getElementById('modal-content');
                const buttonsDiv = document.createElement('div');
                buttonsDiv.style.cssText = 'display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 15px;';

                if (canBid) {
                    [10, 50, 100].forEach(inc => {
                        const bidAmt = currentBid + inc;
                        if (currentBidder.money >= bidAmt) {
                            const btn = document.createElement('button');
                            btn.textContent = `${bidAmt}â‚¬`;
                            btn.style.cssText = 'padding: 8px 15px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;';
                            btn.onclick = () => {
                                closeModal();
                                auctionState.currentBid = bidAmt;
                                auctionState.highestBidder = currentBidderIndex;
                                auctionState.currentBidderIndex = (currentBidderIndex + 1) % gameState.players.length;
                                showAuctionModal(auctionState);
                            };
                            buttonsDiv.appendChild(btn);
                        }
                    });
                }

                const passBtn = document.createElement('button');
                passBtn.textContent = 'âŒ Passar';
                passBtn.style.cssText = 'padding: 8px 15px; background: #f44336; color: white; border: none; border-radius: 5px; cursor: pointer;';
                passBtn.onclick = () => {
                    closeModal();
                    auctionState.passedPlayers.add(currentBidderIndex);
                    auctionState.currentBidderIndex = (currentBidderIndex + 1) % gameState.players.length;
                    showAuctionModal(auctionState);
                };
                buttonsDiv.appendChild(passBtn);
                modalContent.appendChild(buttonsDiv);
            }, 0);
        }

        function showPayRentModal(player, owner, square, rent) {
            const groupInfo = square.group ? PROPERTY_GROUPS[square.group] : null;
            const color = groupInfo?.color || '#2196F3';
            const imageHtml = square.image ? `<div class="property-large-image"><img src="${square.image}" alt="${square.name}"></div>` : '';

            showModal({
                headerHtml: `
                    <div class="property-header" style="background: ${color}">
                        <div style="font-size: 2rem">${square.icon}</div>
                        <div class="property-name">${square.name}</div>
                        <div class="property-movie">Propiedad de ${owner.name}</div>
                    </div>
                `,
                bodyHtml: `
                    ${imageHtml}
                    <p style="font-size: 1.1rem; margin: 20px 0;">
                        Debes pagar <strong style="color: #f44336;">${rent}â‚¬</strong> de alquiler a ${owner.name}.
                    </p>
                `,
                buttons: [{
                    text: `Pagar ${rent}â‚¬`,
                    class: 'btn-pay',
                    action: () => {
                        const ownerIndex = gameState.players.indexOf(owner);
                        player.money -= rent;
                        owner.money += rent;
                        playPayMoney(); // Coin sound

                        // Update stats
                        updateStat('rentPaid', gameState.currentPlayerIndex, rent);
                        updateStat('rentReceived', ownerIndex, rent);

                        updatePlayersPanel();
                        closeModal();
                        addHistory('rent', 'ðŸ’¸', `${player.name} paga ${rent}â‚¬ de lloguer a ${owner.name} (${square.name})`);
                        showMessage(`${player.name} pago ${rent}â‚¬ a ${owner.name}`);
                        checkBankruptcy(player, ownerIndex); // Pass creditor for proper bankruptcy handling
                        endTurn();
                    }
                }]
            });
        }

        function showSquareInfo(square) {
            const groupInfo = square.group ? PROPERTY_GROUPS[square.group] : null;
            const propertyState = gameState.properties[square.id];
            const owner = propertyState ? gameState.players[propertyState.owner] : null;

            // Special handling for chance and chest cards - use landscape layout
            if (square.type === 'chance' || square.type === 'chest') {
                const isChance = square.type === 'chance';
                const cardColor = isChance ? '#FF9800' : '#9C27B0';
                const cardIcon = isChance ? 'ðŸŽ²' : 'ðŸ“¦';
                const cardTitle = isChance ? 'Suerte' : 'Cofre del Tesoro';
                const cardDesc = isChance
                    ? 'Treu una carta de sort! Pot ser bona o dolenta...'
                    : 'Obre el cofre del tresor! Descobreix quÃ¨ amaga...';

                showModal({
                    headerHtml: `
                        <div class="property-header" style="background: ${cardColor}">
                            <div style="font-size: 2.5rem">${cardIcon}</div>
                            <div class="property-name">${cardTitle}</div>
                        </div>
                    `,
                    bodyHtml: `
                        <div class="card-layout">
                            <div class="card-image">
                                <img src="${square.image}" alt="${cardTitle}">
                            </div>
                            <div class="card-text">
                                ${cardDesc}
                            </div>
                        </div>
                    `,
                    buttons: [{
                        text: 'Cerrar',
                        class: 'btn-close',
                        action: closeModal
                    }]
                });
                return;
            }

            const color = groupInfo?.color || '#2196F3';

            let ownerInfo = '';
            if (owner) {
                ownerInfo = `<p style="margin: 10px 0; color: #4CAF50;"><strong>Propietario:</strong> ${owner.name} ${renderTokenSmall(owner.token)}</p>`;
            } else if (square.price) {
                ownerInfo = `<p style="margin: 10px 0; color: #888;"><em>Disponible para comprar</em></p>`;
            }

            let rentHtml = '';
            if (square.rent) {
                rentHtml = `
                    <div class="rent-info">
                        <h4>Alquileres:</h4>
                        <div class="rent-row"><span>Sin casas:</span><span>${square.rent[0]}â‚¬</span></div>
                        <div class="rent-row"><span>1 casa:</span><span>${square.rent[1]}â‚¬</span></div>
                        <div class="rent-row"><span>2 casas:</span><span>${square.rent[2]}â‚¬</span></div>
                        <div class="rent-row"><span>3 casas:</span><span>${square.rent[3]}â‚¬</span></div>
                        <div class="rent-row"><span>4 casas:</span><span>${square.rent[4]}â‚¬</span></div>
                        <div class="rent-row"><span>Hotel:</span><span>${square.rent[5]}â‚¬</span></div>
                    </div>
                `;
            }

            // Large image display
            let imageHtml = '';
            if (square.image) {
                imageHtml = `<div class="property-large-image"><img src="${square.image}" alt="${square.name}"></div>`;
            }

            showModal({
                headerHtml: `
                    <div class="property-header" style="background: ${color}">
                        <div style="font-size: 3rem">${square.icon || ''}</div>
                        <div class="property-name">${square.name}</div>
                        ${groupInfo ? `<div class="property-movie">${groupInfo.name}</div>` : ''}
                    </div>
                `,
                bodyHtml: `
                    ${imageHtml}
                    ${square.price ? `<div class="property-price">${square.price}â‚¬</div>` : ''}
                    ${ownerInfo}
                    ${rentHtml}
                `,
                buttons: [{
                    text: 'Cerrar',
                    class: 'btn-close',
                    action: closeModal
                }]
            });
        }

        // ==========================================
        // CONSTRUCTION SYSTEM
        // ==========================================

        function getPropertiesInGroup(group) {
            return SQUARES.filter(s => s.type === 'property' && s.group === group);
        }

        function playerOwnsFullGroup(playerIndex, group) {
            const groupProperties = getPropertiesInGroup(group);
            return groupProperties.every(prop => {
                const state = gameState.properties[prop.id];
                return state && state.owner === playerIndex;
            });
        }

        // Get minimum houses in a color group for balanced building
        function getMinHousesInGroup(playerIndex, group) {
            const groupProperties = getPropertiesInGroup(group);
            let minHouses = 5;
            groupProperties.forEach(sq => {
                const propState = gameState.properties[sq.id];
                if (propState && propState.owner === playerIndex) {
                    const houses = propState.houses || 0;
                    if (houses < minHouses) minHouses = houses;
                }
            });
            return minHouses;
        }

        // Check if any property in a group is mortgaged
        function groupHasMortgagedProperty(playerIndex, group) {
            const groupProperties = getPropertiesInGroup(group);
            return groupProperties.some(sq => {
                const propState = gameState.properties[sq.id];
                return propState && propState.owner === playerIndex && propState.mortgaged;
            });
        }

        function getBuildableProperties(playerIndex) {
            const player = gameState.players[playerIndex];
            const buildable = [];

            player.properties.forEach(propId => {
                const square = SQUARES[propId];
                if (square.type !== 'property') return;

                // Check if player owns full group
                if (!playerOwnsFullGroup(playerIndex, square.group)) return;

                // Can't build if any property in the group is mortgaged
                if (groupHasMortgagedProperty(playerIndex, square.group)) return;

                const propState = gameState.properties[propId];
                const houses = propState.houses || 0;

                // Balanced building: can only build if this property has the minimum houses in the group
                const minInGroup = getMinHousesInGroup(playerIndex, square.group);
                if (houses > minInGroup) return; // Can't build here until others catch up

                // Can build if less than 5 (4 houses + 1 hotel)
                if (houses < 5) {
                    buildable.push({
                        square,
                        houses,
                        cost: square.houseCost
                    });
                }
            });

            return buildable;
        }

        function showBuildModal() {
            const player = gameState.players[gameState.currentPlayerIndex];
            const buildable = getBuildableProperties(gameState.currentPlayerIndex);

            if (buildable.length === 0) {
                showModal({
                    title: 'Construir',
                    icon: 'ðŸ ',
                    message: 'No puedes construir. Necesitas tener todas las propiedades de un mismo color.',
                    color: '#FF9800',
                    buttons: [{
                        text: 'Entendido',
                        class: 'btn-close',
                        action: closeModal
                    }]
                });
                return;
            }

            // Group properties by color
            const byGroup = {};
            buildable.forEach(item => {
                if (!byGroup[item.square.group]) {
                    byGroup[item.square.group] = [];
                }
                byGroup[item.square.group].push(item);
            });

            let listHtml = '<div class="build-properties-list">';

            for (const [group, items] of Object.entries(byGroup)) {
                const groupInfo = PROPERTY_GROUPS[group];
                listHtml += `<h4 style="color: ${groupInfo.color}; margin: 10px 0 5px;">${groupInfo.name}</h4>`;

                items.forEach(item => {
                    const canAfford = player.money >= item.cost;
                    const housesDisplay = item.houses === 5
                        ? '<div class="mini-hotel"></div>'
                        : Array(item.houses).fill('<div class="mini-house"></div>').join('');

                    const isUpgradingToHotel = item.houses === 4;
                    const noBuildings = isUpgradingToHotel
                        ? gameState.availableHotels <= 0
                        : gameState.availableHouses <= 0;
                    const buttonText = isUpgradingToHotel ? `Hotel ${item.cost}â‚¬` : `Casa ${item.cost}â‚¬`;
                    const isMaxed = item.houses >= 5;
                    const isDisabled = !canAfford || isMaxed || noBuildings;

                    let disabledReason = '';
                    if (isMaxed) disabledReason = 'Max';
                    else if (noBuildings) disabledReason = isUpgradingToHotel ? 'No hotels!' : 'No cases!';
                    else disabledReason = buttonText;

                    listHtml += `
                        <div class="build-property-item" style="border-left-color: ${groupInfo.color}">
                            <div class="info">
                                <span>${item.square.icon}</span>
                                <span>${item.square.name}</span>
                                <div class="houses-display">${housesDisplay}</div>
                            </div>
                            <button class="btn-add-house"
                                    data-square-id="${item.square.id}"
                                    ${isDisabled ? 'disabled' : ''}>
                                ${disabledReason}
                            </button>
                        </div>
                    `;
                });
            }

            listHtml += '</div>';
            listHtml += `<p style="text-align: center; color: #666; margin-top: 10px;">Tu dinero: <strong style="color: #4CAF50;">${player.money}â‚¬</strong></p>`;
            listHtml += `<p style="text-align: center; color: #888; font-size: 0.9rem;">ðŸ  Cases: ${gameState.availableHouses} | ðŸ¨ Hotels: ${gameState.availableHotels}</p>`;

            showModal({
                headerHtml: `
                    <div class="property-header" style="background: #4CAF50">
                        <div style="font-size: 2rem">ðŸ </div>
                        <div class="property-name">Construir</div>
                        <div class="property-movie">Compra casas y hoteles</div>
                    </div>
                `,
                bodyHtml: listHtml,
                buttons: [{
                    text: 'Cerrar',
                    class: 'btn-close',
                    action: closeModal
                }]
            });

            // Add click handlers to build buttons
            setTimeout(() => {
                document.querySelectorAll('.btn-add-house').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const squareId = parseInt(e.target.dataset.squareId);
                        buildHouse(squareId);
                    });
                });
            }, 0);
        }

        function buildHouse(squareId) {
            const player = gameState.players[gameState.currentPlayerIndex];
            const square = SQUARES[squareId];
            const propState = gameState.properties[squareId];
            const cost = square.houseCost;
            const currentHouses = propState.houses || 0;
            const isUpgradingToHotel = currentHouses === 4;

            if (player.money < cost) {
                showMessage('No tienes suficiente dinero!');
                return;
            }

            // Check building availability
            if (isUpgradingToHotel) {
                if (gameState.availableHotels <= 0) {
                    showMessage('No quedan hotels disponibles!');
                    return;
                }
            } else {
                if (gameState.availableHouses <= 0) {
                    showMessage('No quedan cases disponibles!');
                    return;
                }
            }

            player.money -= cost;
            playPayMoney(); // Coin sound
            propState.houses = currentHouses + 1;

            // Update building counts
            if (isUpgradingToHotel) {
                gameState.availableHotels--;
                gameState.availableHouses += 4; // Return 4 houses to pool
            } else {
                gameState.availableHouses--;
            }

            // Update stats
            updateStat('totalMoneySpent', gameState.currentPlayerIndex, cost);

            updatePlayersPanel();
            updateSquareDisplay(squareId);

            const buildType = propState.houses === 5 ? 'un hotel' : 'una casa';
            addHistory('build', 'ðŸ—ï¸', `${player.name} construeix ${buildType} a ${square.name} (${cost}â‚¬)`);
            showMessage(`${player.name} construyo ${buildType} en ${square.name}! (Cases: ${gameState.availableHouses}, Hotels: ${gameState.availableHotels})`);

            // Refresh the build modal
            closeModal();
            setTimeout(() => showBuildModal(), 100);
        }

        // ==========================================
        // MORTGAGE SYSTEM
        // ==========================================

        function showMortgageModal() {
            const player = gameState.players[gameState.currentPlayerIndex];

            // Get properties that can be mortgaged or unmortgaged
            const mortgageable = [];
            const unmortgageable = [];

            player.properties.forEach(propId => {
                const square = SQUARES[propId];
                const propState = gameState.properties[propId];

                if (propState.mortgaged) {
                    const unmortgageCost = Math.floor(square.price * 0.55);
                    unmortgageable.push({
                        square,
                        cost: unmortgageCost,
                        canAfford: player.money >= unmortgageCost
                    });
                } else {
                    const houses = propState.houses || 0;
                    if (houses === 0) {
                        mortgageable.push({
                            square,
                            value: Math.floor(square.price * 0.5)
                        });
                    }
                }
            });

            if (mortgageable.length === 0 && unmortgageable.length === 0) {
                showModal({
                    title: 'Hipoteca',
                    icon: 'ðŸ¦',
                    message: 'No tens propietats per hipotecar o deshipotecar.',
                    color: '#9C27B0',
                    buttons: [{ text: 'EntÃ¨s', class: 'btn-close', action: closeModal }]
                });
                return;
            }

            let listHtml = '<div class="mortgage-list" style="max-height: 400px; overflow-y: auto;">';

            if (mortgageable.length > 0) {
                listHtml += '<h4 style="color: #E91E63; margin: 10px 0;">ðŸ“¤ Hipotecar</h4>';
                mortgageable.forEach(item => {
                    const groupInfo = PROPERTY_GROUPS[item.square.group] || { color: '#888' };
                    listHtml += `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; margin: 5px 0; background: #f9f9f9; border-radius: 5px; border-left: 4px solid ${groupInfo.color};">
                            <span>${item.square.name}</span>
                            <button class="btn-mortgage" data-action="mortgage" data-square-id="${item.square.id}" style="background: #E91E63; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">+${item.value}â‚¬</button>
                        </div>`;
                });
            }

            if (unmortgageable.length > 0) {
                listHtml += '<h4 style="color: #4CAF50; margin: 15px 0 10px;">ðŸ“¥ Deshipotecar</h4>';
                unmortgageable.forEach(item => {
                    const groupInfo = PROPERTY_GROUPS[item.square.group] || { color: '#888' };
                    listHtml += `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; margin: 5px 0; background: #fff3e0; border-radius: 5px; border-left: 4px solid ${groupInfo.color};">
                            <span>${item.square.name} <small style="color: #FF9800;">(hip.)</small></span>
                            <button class="btn-mortgage" data-action="unmortgage" data-square-id="${item.square.id}" ${!item.canAfford ? 'disabled' : ''} style="background: ${item.canAfford ? '#4CAF50' : '#ccc'}; color: white; border: none; padding: 5px 10px; border-radius: 5px;">-${item.cost}â‚¬</button>
                        </div>`;
                });
            }

            listHtml += '</div>';
            listHtml += `<p style="text-align: center; color: #666; margin-top: 15px;">Diners: <strong style="color: #4CAF50;">${player.money}â‚¬</strong></p>`;

            showModal({
                headerHtml: `<div class="property-header" style="background: #9C27B0"><div style="font-size: 2rem">ðŸ¦</div><div class="property-name">Hipoteca</div></div>`,
                bodyHtml: listHtml,
                buttons: [{ text: 'Tancar', class: 'btn-close', action: closeModal }]
            });

            setTimeout(() => {
                document.querySelectorAll('.btn-mortgage').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const action = btn.dataset.action;
                        const squareId = parseInt(btn.dataset.squareId);
                        closeModal();
                        if (action === 'mortgage') mortgageProperty(squareId);
                        else unmortgageProperty(squareId);
                    });
                });
            }, 0);
        }

        function mortgageProperty(squareId) {
            const player = gameState.players[gameState.currentPlayerIndex];
            const square = SQUARES[squareId];
            const propState = gameState.properties[squareId];
            const mortgageValue = Math.floor(square.price * 0.5);

            propState.mortgaged = true;
            player.money += mortgageValue;
            updatePlayersPanel();
            updateSquareDisplay(squareId);
            addHistory('mortgage', 'ðŸ¦', `${player.name} hipoteca ${square.name} per ${mortgageValue}â‚¬`);
            showMessage(`${player.name} hipoteca ${square.name} i rep ${mortgageValue}â‚¬`);
            setTimeout(() => showMortgageModal(), 100);
        }

        function unmortgageProperty(squareId) {
            const player = gameState.players[gameState.currentPlayerIndex];
            const square = SQUARES[squareId];
            const propState = gameState.properties[squareId];
            const unmortgageCost = Math.floor(square.price * 0.55);

            if (player.money < unmortgageCost) {
                showMessage('No tens prou diners!');
                return;
            }

            propState.mortgaged = false;
            player.money -= unmortgageCost;
            playPayMoney(); // Coin sound
            updatePlayersPanel();
            updateSquareDisplay(squareId);
            addHistory('mortgage', 'ðŸ¦', `${player.name} deshipoteca ${square.name} per ${unmortgageCost}â‚¬`);
            showMessage(`${player.name} deshipoteca ${square.name} pagant ${unmortgageCost}â‚¬`);
            setTimeout(() => showMortgageModal(), 100);
        }

        function showModal({ title, icon, message, color, headerHtml, bodyHtml, buttons, landscape }) {
            const overlay = document.getElementById('modal-overlay');
            const content = document.getElementById('modal-content');

            // Reset classes and add landscape if needed
            content.className = 'modal' + (landscape ? ' landscape' : '');

            let html = '';

            if (headerHtml) {
                html += headerHtml;
            } else if (title) {
                html += `
                    <div class="property-header" style="background: ${color || '#2196F3'}">
                        ${icon ? `<div style="font-size: 2rem">${icon}</div>` : ''}
                        <div class="property-name">${title}</div>
                    </div>
                `;
            }

            if (bodyHtml) {
                html += bodyHtml;
            } else if (message) {
                html += `<p style="margin: 20px 0;">${message}</p>`;
            }

            html += '<div class="modal-buttons">';
            buttons.forEach((btn, i) => {
                html += `<button class="${btn.class}" data-btn-index="${i}">${btn.text}</button>`;
            });
            html += '</div>';

            content.innerHTML = html;

            // Attach button handlers
            buttons.forEach((btn, i) => {
                content.querySelector(`[data-btn-index="${i}"]`).addEventListener('click', btn.action);
            });

            overlay.classList.add('visible');
        }

        function closeModal() {
            document.getElementById('modal-overlay').classList.remove('visible');
        }

        // ==========================================
        // GAME ACTIONS
        // ==========================================

        function buyProperty(player, square) {
            // Check monopolies before buying
            const monopoliesBefore = getPlayerMonopolies(gameState.currentPlayerIndex);

            player.money -= square.price;
            player.properties.push(square.id);
            gameState.properties[square.id] = {
                owner: gameState.currentPlayerIndex,
                houses: 0
            };

            // Update stats
            updateStat('propertiesBought', gameState.currentPlayerIndex, 1);
            updateStat('totalMoneySpent', gameState.currentPlayerIndex, square.price);

            playPayMoney(); // Sound for spending money
            updatePlayersPanel();
            updateSquareDisplay(square.id);
            closeModal();
            addHistory('buy', 'ðŸ ', `${player.name} ha comprat ${square.name} per ${square.price}â‚¬`);

            // Check if player just completed a monopoly
            const monopoliesAfter = getPlayerMonopolies(gameState.currentPlayerIndex);
            if (monopoliesAfter.length > monopoliesBefore.length) {
                const newMonopoly = monopoliesAfter.find(m => !monopoliesBefore.some(mb => mb.group === m.group));
                if (newMonopoly) {
                    addHistory('buy', 'ðŸ‘‘', `${player.name} ha aconseguit el MONOPOLI de ${newMonopoly.name}!`);
                    showMessage(`ðŸŽ‰ ${player.name} tÃ© el MONOPOLI de ${newMonopoly.name}! ðŸŽ‰`);
                    createConfetti();
                } else {
                    showMessage(`${player.name} ha comprat ${square.name} per ${square.price}â‚¬!`);
                }
            } else {
                showMessage(`${player.name} ha comprat ${square.name} per ${square.price}â‚¬!`);
            }

            endTurn();
        }

        function checkBankruptcy(player, creditorIndex = null) {
            if (player.money >= 0) return;

            const playerIndex = gameState.players.indexOf(player);

            // Calculate total assets (properties + houses)
            let totalAssets = 0;
            player.properties.forEach(propId => {
                const square = SQUARES[propId];
                const propState = gameState.properties[propId];
                if (!propState.mortgaged) {
                    totalAssets += Math.floor(square.price * 0.5); // Mortgage value
                }
                if (propState.houses > 0) {
                    totalAssets += propState.houses * Math.floor(square.houseCost * 0.5); // Sell houses at half price
                }
            });

            // If player can cover debt by selling/mortgaging, don't declare bankruptcy yet
            if (player.money + totalAssets >= 0) {
                showMessage(`âš ï¸ ${player.name} tÃ© deutes! Hauria d'hipotecar propietats.`);
                return;
            }

            // Player is truly bankrupt
            player.bankrupt = true;
            addHistory('bankruptcy', 'ðŸ’€', `${player.name} ha fet fallida!`);

            // Return houses/hotels to pool
            player.properties.forEach(propId => {
                const propState = gameState.properties[propId];
                if (propState.houses > 0) {
                    if (propState.houses === 5) {
                        gameState.availableHotels++;
                    } else {
                        gameState.availableHouses += propState.houses;
                    }
                }
            });

            if (creditorIndex !== null && creditorIndex !== undefined) {
                // Owing to another player - transfer everything
                const creditor = gameState.players[creditorIndex];

                // Transfer properties
                player.properties.forEach(propId => {
                    const propState = gameState.properties[propId];
                    propState.owner = creditorIndex;
                    propState.houses = 0; // Already sold
                    creditor.properties.push(propId);
                    updateSquareDisplay(propId);
                });

                // Transfer Get Out of Jail cards
                creditor.getOutOfJailCards += player.getOutOfJailCards;
                player.getOutOfJailCards = 0;

                // Clear bankrupt player's properties
                player.properties = [];
                player.money = 0;

                showMessage(`ðŸ’€ ${player.name} fa fallida! Les propietats passen a ${creditor.name}`);
            } else {
                // Owing to bank - auction all properties
                const propsToAuction = [...player.properties];
                player.properties = [];
                player.money = 0;
                player.getOutOfJailCards = 0;

                // Clear ownership and auction each property
                propsToAuction.forEach(propId => {
                    delete gameState.properties[propId];
                    updateSquareDisplay(propId);
                });

                showMessage(`ðŸ’€ ${player.name} fa fallida! Les propietats tornen al banc.`);

                // Could trigger auctions here, but for simplicity properties just return to bank
            }

            updatePlayersPanel();

            // Check if only one player remains
            const activePlayers = gameState.players.filter(p => !p.bankrupt);
            if (activePlayers.length === 1) {
                setTimeout(() => {
                    showModal({
                        title: 'ðŸ† VICTÃ’RIA!',
                        icon: 'ðŸŽ‰',
                        message: `${activePlayers[0].name} ha guanyat la partida!`,
                        color: '#FFD700',
                        buttons: [{
                            text: 'Nova Partida',
                            class: 'btn-buy',
                            action: () => location.reload()
                        }]
                    });
                }, 1000);
            }
        }

        function endTurn() {
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];

            // Check if player rolled doubles and can roll again (not in jail)
            if (gameState.lastRollWasDoubles && !currentPlayer.inJail) {
                gameState.diceRolled = false;
                gameState.lastRollWasDoubles = false; // Reset for next roll
                document.getElementById('roll-dice').disabled = false;
                setTimeout(() => {
                    showMessage(`ðŸŽ² ${currentPlayer.name} ha tret DOBLES! Torna a tirar!`);
                }, 500);
                return;
            }

            // Normal turn end - reset doubles counters
            gameState.diceRolled = false;
            gameState.consecutiveDoubles = 0;
            gameState.lastRollWasDoubles = false;
            gameState.stats.turnsPlayed++;

            // Update turn counter display
            updateTurnCounter();

            // Check if turn limit reached
            if (gameConfig.maxTurns > 0 && gameState.stats.turnsPlayed >= gameConfig.maxTurns) {
                endGameByTimeOrTurns();
                return;
            }

            // Find next active player
            let nextIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
            let attempts = 0;

            while (gameState.players[nextIndex].bankrupt && attempts < gameState.players.length) {
                nextIndex = (nextIndex + 1) % gameState.players.length;
                attempts++;
            }

            // Check for winner
            const activePlayers = gameState.players.filter(p => !p.bankrupt);
            if (activePlayers.length === 1) {
                showMessage(`Â¡${activePlayers[0].name} ha ganado!`);
                document.getElementById('roll-dice').disabled = true;
                return;
            }

            gameState.currentPlayerIndex = nextIndex;
            const nextPlayer = gameState.players[nextIndex];

            updateCurrentPlayerDisplay();
            updatePlayersPanel();
            if (typeof updateZoomView === 'function') updateZoomView();

            // Handle jail - improved mechanics
            if (nextPlayer.inJail) {
                document.getElementById('roll-dice').disabled = true;
                setTimeout(() => {
                    handleJailTurn(nextPlayer);
                }, 500);
                return;
            }

            document.getElementById('roll-dice').disabled = false;

            setTimeout(() => {
                showMessage(`Turno de ${nextPlayer.name}. Tira els daus!`);
            }, 500);
        }

        // ==========================================
        // UI UPDATES
        // ==========================================

        function updatePlayersPanel() {
            const panel = document.getElementById('players-panel');

            // Find or create player cards container
            let cardsContainer = panel.querySelector('.player-cards-container');
            if (!cardsContainer) {
                cardsContainer = document.createElement('div');
                cardsContainer.className = 'player-cards-container';
                panel.appendChild(cardsContainer);
            }

            // Clear player cards
            cardsContainer.innerHTML = '';

            gameState.players.forEach((player, index) => {
                const card = document.createElement('div');
                card.className = `player-card ${index === gameState.currentPlayerIndex ? 'active' : ''}`;

                if (player.bankrupt) {
                    card.style.opacity = '0.5';
                }

                card.innerHTML = `
                    <div class="header">
                        <span class="token">${renderToken(player.token)}</span>
                        <span class="name">${player.name}</span>
                        <span class="turn-indicator">Tu turno</span>
                    </div>
                    <div class="money">${player.money}â‚¬</div>
                    <div class="properties-count">ðŸ  ${player.properties.length} propiedades</div>
                `;

                card.style.cursor = 'pointer';
                card.addEventListener('click', () => showPlayerProperties(index));

                cardsContainer.appendChild(card);
            });

            // Also update the money bar
            updateMoneyBar();
        }

        function getPlayerMonopolies(playerIndex) {
            const monopolies = [];
            const playerProperties = gameState.players[playerIndex].properties;

            // Count properties per group owned by this player
            const groupCounts = {};
            const groupTotals = {};

            // First, count total properties in each group
            SQUARES.forEach(sq => {
                if (sq.type === 'property' && sq.group) {
                    groupTotals[sq.group] = (groupTotals[sq.group] || 0) + 1;
                }
            });

            // Count what this player owns
            playerProperties.forEach(propId => {
                const sq = SQUARES[propId];
                if (sq && sq.group) {
                    groupCounts[sq.group] = (groupCounts[sq.group] || 0) + 1;
                }
            });

            // Check for complete sets
            for (const group in groupCounts) {
                if (groupCounts[group] === groupTotals[group]) {
                    monopolies.push({
                        group,
                        color: PROPERTY_GROUPS[group].color,
                        name: PROPERTY_GROUPS[group].name
                    });
                }
            }

            return monopolies;
        }

        function showPlayerProperties(playerIndex) {
            const player = gameState.players[playerIndex];
            const properties = player.properties;

            let propertiesHtml = '';
            if (properties.length === 0) {
                propertiesHtml = '<div class="no-properties">Aquest jugador no tÃ© propietats</div>';
            } else {
                propertiesHtml = '<div class="player-properties-grid">';
                properties.forEach(propId => {
                    const square = SQUARES[propId];
                    const propState = gameState.properties[propId];
                    const groupInfo = square.group ? PROPERTY_GROUPS[square.group] : null;
                    const color = groupInfo?.color || '#607D8B';
                    const isMortgaged = propState?.mortgaged;
                    const houses = propState?.houses || 0;

                    let housesText = '';
                    if (square.type === 'property' && square.rent) {
                        if (houses === 5) {
                            housesText = 'ðŸ¨ Hotel';
                        } else if (houses > 0) {
                            housesText = 'ðŸ '.repeat(houses);
                        }
                    }

                    const imageHtml = square.image
                        ? `<img class="prop-image" src="${square.image}" alt="${square.name}">`
                        : `<div class="prop-icon">${square.icon}</div>`;

                    propertiesHtml += `
                        <div class="player-property-card ${isMortgaged ? 'mortgaged' : ''}" data-prop-id="${propId}">
                            <div class="prop-color-bar" style="background: ${color}"></div>
                            <div class="prop-content">
                                ${imageHtml}
                                <div class="prop-name">${square.name}</div>
                                ${housesText ? `<div class="prop-houses">${housesText}</div>` : ''}
                            </div>
                        </div>
                    `;
                });
                propertiesHtml += '</div>';
            }

            showModal({
                headerHtml: `
                    <div class="property-header" style="background: linear-gradient(135deg, #2196F3, #1976D2)">
                        <div style="font-size: 2rem">${renderToken(player.token)}</div>
                        <div class="property-name">Propietats de ${player.name}</div>
                        <div class="property-movie">${player.money}â‚¬ Â· ${properties.length} propietats</div>
                    </div>
                `,
                bodyHtml: propertiesHtml,
                landscape: properties.length > 0,
                buttons: [
                    {
                        text: 'Tancar',
                        class: 'btn-close',
                        action: closeModal
                    }
                ]
            });

            // Add click handlers to property cards after modal is shown
            setTimeout(() => {
                document.querySelectorAll('.player-property-card').forEach(card => {
                    card.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const propId = parseInt(card.dataset.propId);
                        const square = SQUARES[propId];
                        showPropertyDetails(square);
                    });
                });
            }, 100);
        }

        function showPropertyDetails(square) {
            const groupInfo = square.group ? PROPERTY_GROUPS[square.group] : null;
            const color = groupInfo?.color || '#607D8B';
            const propState = gameState.properties[square.id];
            const houses = propState?.houses || 0;

            let rentHtml = '';
            if (square.rent) {
                rentHtml = `
                    <div class="rent-info">
                        <h4>Alquileres:</h4>
                        <div class="rent-row"><span>Sin casas:</span><span>${square.rent[0]}â‚¬</span></div>
                        <div class="rent-row"><span>1 casa:</span><span>${square.rent[1]}â‚¬</span></div>
                        <div class="rent-row"><span>2 casas:</span><span>${square.rent[2]}â‚¬</span></div>
                        <div class="rent-row"><span>3 casas:</span><span>${square.rent[3]}â‚¬</span></div>
                        <div class="rent-row"><span>4 casas:</span><span>${square.rent[4]}â‚¬</span></div>
                        <div class="rent-row"><span>Hotel:</span><span>${square.rent[5]}â‚¬</span></div>
                    </div>
                `;
            } else if (square.type === 'station') {
                rentHtml = `
                    <div class="rent-info">
                        <h4>Alquileres:</h4>
                        <div class="rent-row"><span>1 estaciÃ³:</span><span>25â‚¬</span></div>
                        <div class="rent-row"><span>2 estacions:</span><span>50â‚¬</span></div>
                        <div class="rent-row"><span>3 estacions:</span><span>100â‚¬</span></div>
                        <div class="rent-row"><span>4 estacions:</span><span>200â‚¬</span></div>
                    </div>
                `;
            } else if (square.type === 'utility') {
                rentHtml = `
                    <div class="rent-info">
                        <h4>Alquileres:</h4>
                        <div class="rent-row"><span>1 servei:</span><span>4x daus</span></div>
                        <div class="rent-row"><span>2 serveis:</span><span>10x daus</span></div>
                    </div>
                `;
            }

            const hasImage = square.image;
            let bodyContent = '';
            if (hasImage) {
                bodyContent = `
                    <div class="property-landscape">
                        <div class="property-image-side">
                            <img src="${square.image}" alt="${square.name}">
                        </div>
                        <div class="property-info-side">
                            ${houses === 5 ? '<p style="color: #9C27B0; font-weight: bold;">ðŸ¨ Hotel</p>' : houses > 0 ? `<p style="color: #4CAF50; font-weight: bold;">${'ðŸ '.repeat(houses)} ${houses} casa${houses > 1 ? 's' : ''}</p>` : ''}
                            ${rentHtml}
                        </div>
                    </div>
                `;
            } else {
                bodyContent = `
                    ${houses === 5 ? '<p style="color: #9C27B0; font-weight: bold;">ðŸ¨ Hotel</p>' : houses > 0 ? `<p style="color: #4CAF50; font-weight: bold;">${'ðŸ '.repeat(houses)} ${houses} casa${houses > 1 ? 's' : ''}</p>` : ''}
                    ${rentHtml}
                `;
            }

            showModal({
                headerHtml: `
                    <div class="property-header" style="background: ${color}">
                        <div style="font-size: 2rem">${square.icon}</div>
                        <div class="property-name">${square.name}</div>
                        ${groupInfo ? `<div class="property-movie">${groupInfo.name}</div>` : ''}
                    </div>
                `,
                bodyHtml: bodyContent,
                landscape: hasImage,
                buttons: [
                    {
                        text: 'Tancar',
                        class: 'btn-close',
                        action: closeModal
                    }
                ]
            });
        }

        function updateMoneyBar() {
            const bar = document.getElementById('money-bar');
            if (!bar || !gameState.started) return;

            bar.innerHTML = gameState.players.map((player, index) => {
                const isCurrent = index === gameState.currentPlayerIndex;
                const classes = ['money-player'];
                if (isCurrent) classes.push('current');
                if (player.bankrupt) classes.push('bankrupt');

                // Get monopolies for this player
                const monopolies = getPlayerMonopolies(index);
                const monopolyIndicators = monopolies.map(m =>
                    `<span class="monopoly-dot" style="background: ${m.color}" title="${m.name}"></span>`
                ).join('');

                return `
                    <div class="${classes.join(' ')}">
                        <span class="token">${renderTokenSmall(player.token)}</span>
                        <div class="info">
                            <span class="name">${player.name}</span>
                            <span class="amount ${player.money < 0 ? 'negative' : ''}">${player.money}â‚¬</span>
                            ${monopolies.length > 0 ? `<div class="monopolies">${monopolyIndicators}</div>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateCurrentPlayerDisplay() {
            const player = gameState.players[gameState.currentPlayerIndex];
            document.getElementById('current-player-name').innerHTML =
                `${renderTokenSmall(player.token)} ${player.name}`;
        }

        function showMessage(text) {
            const msgArea = document.getElementById('message-area');
            msgArea.textContent = text;
            msgArea.classList.add('visible');

            setTimeout(() => {
                msgArea.classList.remove('visible');
            }, 3000);
        }

        // ==========================================
        // HISTORY & STATISTICS
        // ==========================================

        function addHistory(type, icon, text) {
            const now = new Date();
            const time = now.toLocaleTimeString('ca-ES', { hour: '2-digit', minute: '2-digit' });

            gameState.history.unshift({
                type,
                icon,
                text,
                time,
                timestamp: now.getTime()
            });

            // Keep only last 100 entries
            if (gameState.history.length > 100) {
                gameState.history = gameState.history.slice(0, 100);
            }

            updateHistoryPanel();
        }

        function updateHistoryPanel() {
            const container = document.getElementById('history-list');
            if (!container) return;

            if (gameState.history.length === 0) {
                container.innerHTML = '<div class="history-empty">La partida encara no ha comenÃ§at...</div>';
                return;
            }

            container.innerHTML = gameState.history.map(entry => `
                <div class="history-entry ${entry.type}">
                    <span class="time">${entry.time}</span>
                    <span class="icon">${entry.icon}</span>
                    <span class="text">${entry.text}</span>
                </div>
            `).join('');
        }

        function initStats() {
            gameState.players.forEach((_, index) => {
                gameState.stats.totalMoneyEarned[index] = 0;
                gameState.stats.totalMoneySpent[index] = 0;
                gameState.stats.propertiesBought[index] = 0;
                gameState.stats.rentPaid[index] = 0;
                gameState.stats.rentReceived[index] = 0;
                gameState.stats.timesInJail[index] = 0;
                gameState.stats.doublesRolled[index] = 0;
            });
        }

        function updateStat(statName, playerIndex, amount) {
            if (gameState.stats[statName] && gameState.stats[statName][playerIndex] !== undefined) {
                gameState.stats[statName][playerIndex] += amount;
            }
        }

        function showPanelTab(tab) {
            const historyPanel = document.getElementById('history-panel');
            const statsPanel = document.getElementById('stats-panel');
            const tabs = document.querySelectorAll('.panel-tab');

            tabs.forEach(t => t.classList.remove('active'));

            if (tab === 'history') {
                historyPanel.classList.remove('hidden');
                statsPanel.classList.add('hidden');
                tabs[0].classList.add('active');
            } else {
                historyPanel.classList.add('hidden');
                statsPanel.classList.remove('hidden');
                tabs[1].classList.add('active');
                updateStatsPanel();
            }
        }

        function updateStatsPanel() {
            const container = document.getElementById('stats-content');
            if (!container || !gameState.started) return;

            const players = gameState.players.filter(p => !p.bankrupt);
            const maxMoney = Math.max(...players.map(p => p.money), 1);

            let html = `
                <div class="stats-section">
                    <h4>ðŸ’° Diners Actuals</h4>
                    ${players.map(p => {
                        const pct = (p.money / maxMoney) * 100;
                        const color = getPlayerColor(gameState.players.indexOf(p));
                        return `
                            <div class="stat-row">
                                <span class="player-name">${renderTokenSmall(p.token)} ${p.name}</span>
                                <span class="value">${p.money}â‚¬</span>
                            </div>
                            <div class="stat-bar">
                                <div class="stat-bar-fill" style="width: ${pct}%; background: ${color}"></div>
                            </div>
                        `;
                    }).join('')}
                </div>

                <div class="stats-section">
                    <h4>ðŸ  Propietats Comprades</h4>
                    ${gameState.players.map((p, i) => {
                        if (p.bankrupt) return '';
                        const count = gameState.stats.propertiesBought[i] || 0;
                        return `
                            <div class="stat-row">
                                <span class="player-name">${renderTokenSmall(p.token)} ${p.name}</span>
                                <span class="value">${count}</span>
                            </div>
                        `;
                    }).join('')}
                </div>

                <div class="stats-section">
                    <h4>ðŸ’¸ Lloguer Pagat / Rebut</h4>
                    ${gameState.players.map((p, i) => {
                        if (p.bankrupt) return '';
                        const paid = gameState.stats.rentPaid[i] || 0;
                        const received = gameState.stats.rentReceived[i] || 0;
                        const net = received - paid;
                        return `
                            <div class="stat-row">
                                <span class="player-name">${renderTokenSmall(p.token)} ${p.name}</span>
                                <span class="value ${net >= 0 ? 'positive' : 'negative'}">${net >= 0 ? '+' : ''}${net}â‚¬</span>
                            </div>
                        `;
                    }).join('')}
                </div>

                <div class="stats-section">
                    <h4>ðŸŽ² Dobles Tirats / ðŸ”’ Vegades a la PresÃ³</h4>
                    ${gameState.players.map((p, i) => {
                        if (p.bankrupt) return '';
                        const doubles = gameState.stats.doublesRolled[i] || 0;
                        const jails = gameState.stats.timesInJail[i] || 0;
                        return `
                            <div class="stat-row">
                                <span class="player-name">${renderTokenSmall(p.token)} ${p.name}</span>
                                <span class="value">ðŸŽ² ${doubles} / ðŸ”’ ${jails}</span>
                            </div>
                        `;
                    }).join('')}
                </div>

                <div class="stats-section">
                    <h4>ðŸ“ˆ Torns Jugats</h4>
                    <div class="stat-row">
                        <span>Total de torns:</span>
                        <span class="value">${gameState.stats.turnsPlayed}</span>
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        function getPlayerColor(index) {
            const colors = ['#e91e63', '#2196F3', '#4CAF50', '#FF9800', '#9C27B0', '#00BCD4'];
            return colors[index % colors.length];
        }

        // ==========================================
        // SAVE / LOAD GAME
        // ==========================================

        function saveGame() {
            const saveData = {
                players: gameState.players,
                currentPlayerIndex: gameState.currentPlayerIndex,
                properties: gameState.properties,
                chanceDeck: gameState.chanceDeck,
                chestDeck: gameState.chestDeck,
                history: gameState.history,
                stats: gameState.stats,
                timestamp: new Date().toISOString()
            };
            localStorage.setItem('disneyMonopolySave', JSON.stringify(saveData));

            // Show save indicator
            const indicator = document.createElement('div');
            indicator.className = 'save-indicator';
            indicator.textContent = 'âœ“ Partida guardada!';
            document.body.appendChild(indicator);
            setTimeout(() => indicator.remove(), 2000);
        }

        function loadGame() {
            const saveData = localStorage.getItem('disneyMonopolySave');
            if (!saveData) {
                showMessage('No hi ha cap partida guardada');
                return;
            }

            const data = JSON.parse(saveData);
            gameState.players = data.players;
            gameState.currentPlayerIndex = data.currentPlayerIndex;
            gameState.properties = data.properties;
            gameState.chanceDeck = data.chanceDeck || shuffleArray(CHANCE_CARDS);
            gameState.chestDeck = data.chestDeck || shuffleArray(CHEST_CARDS);
            gameState.history = data.history || [];
            gameState.stats = data.stats || {
                turnsPlayed: 0,
                totalMoneyEarned: {},
                totalMoneySpent: {},
                propertiesBought: {},
                rentPaid: {},
                rentReceived: {},
                timesInJail: {},
                doublesRolled: {}
            };
            gameState.started = true;
            gameState.diceRolled = false;

            document.getElementById('setup-screen').style.display = 'none';
            document.getElementById('game-screen').classList.add('visible');

            createBoard();
            updatePlayersPanel();
            updateCurrentPlayerDisplay();
            positionAllTokens();
            updateAllSquareDisplays();
            updateHistoryPanel();

            addHistory('move', 'ðŸ“‚', 'Partida carregada');
            showMessage('Partida carregada! Turno de ' + gameState.players[gameState.currentPlayerIndex].name);
        }

        function hasSavedGame() {
            return localStorage.getItem('disneyMonopolySave') !== null;
        }

        // ==========================================
        // RULES
        // ==========================================

        function showRules() {
            showModal({
                headerHtml: `
                    <div class="property-header" style="background: #FF9800">
                        <div style="font-size: 2rem">ðŸ“–</div>
                        <div class="property-name">Regles del Joc</div>
                    </div>
                `,
                bodyHtml: `
                    <div class="rules-content">
                        <h4>ðŸŽ¯ Objectiu</h4>
                        <p>Ser l'ultim jugador sense estar en bancarrota!</p>

                        <h4>ðŸŽ² Com jugar</h4>
                        <ul>
                            <li>Tira els daus i mou la teva fitxa</li>
                            <li>Si caus en una propietat lliure, pots comprar-la</li>
                            <li>Si caus en propietat d'un altre, paga lloguer</li>
                            <li>Passa per SORTIDA i cobra 200â‚¬</li>
                        </ul>

                        <h4>ðŸ  Construccio</h4>
                        <ul>
                            <li>Necessites TOTES les propietats d'un color</li>
                            <li>Compra cases per augmentar el lloguer</li>
                            <li>Amb 4 cases pots construir un hotel</li>
                        </ul>

                        <h4>ðŸš‚ Estacions</h4>
                        <ul>
                            <li>1 estacio: 25â‚¬</li>
                            <li>2 estacions: 50â‚¬</li>
                            <li>3 estacions: 100â‚¬</li>
                            <li>4 estacions: 200â‚¬</li>
                        </ul>

                        <h4>ðŸ”’ Preso</h4>
                        <ul>
                            <li>Si caus a "Anar a Preso", vas directe</li>
                            <li>Per sortir: paga 50â‚¬ o tira dobles</li>
                        </ul>

                        <h4>ðŸŽ´ Cartes</h4>
                        <p>Les cartes de Suerte i Cofre poden donar-te diners, fer-te pagar, o moure't pel tauler!</p>
                    </div>
                `,
                buttons: [{
                    text: 'EntÃ¨s!',
                    class: 'btn-close',
                    action: closeModal
                }]
            });
        }

        // ==========================================
        // IMPROVED JAIL MECHANICS
        // ==========================================

        function handleJailTurn(player) {
            player.jailTurns = (player.jailTurns || 0) + 1;

            // Build jail options HTML
            let jailOptionsHtml = `
                <div class="jail-options">
                    <div class="jail-option" data-action="pay">
                        <span class="option-icon">ðŸ’°</span>
                        <span class="option-text">Pagar fianÃ§a</span>
                        <span class="option-cost">${gameConfig.jailFine}â‚¬</span>
                    </div>
                    <div class="jail-option" data-action="roll">
                        <span class="option-icon">ðŸŽ²</span>
                        <span class="option-text">Tirar els daus (dobles per sortir)</span>
                    </div>`;

            // Add card option if player has one
            if (player.getOutOfJailCards > 0) {
                jailOptionsHtml += `
                    <div class="jail-option" data-action="card" style="background: linear-gradient(135deg, #FFD700, #FFA500);">
                        <span class="option-icon">ðŸŽ«</span>
                        <span class="option-text">Usar Targeta Sortir Gratis</span>
                        <span class="option-cost">(Tens ${player.getOutOfJailCards})</span>
                    </div>`;
            }

            jailOptionsHtml += '</div>';

            showModal({
                headerHtml: `
                    <div class="property-header" style="background: #FF5722">
                        <div style="font-size: 2rem">ðŸ”’</div>
                        <div class="property-name">Estas a la Preso!</div>
                    </div>
                `,
                bodyHtml: `
                    <p style="margin: 15px 0; color: #666;">Torn ${player.jailTurns} a la preso. Com vols sortir?</p>
                    ${jailOptionsHtml}
                `,
                buttons: []
            });

            // Add click handlers after modal is shown
            setTimeout(() => {
                document.querySelectorAll('.jail-option').forEach(option => {
                    option.addEventListener('click', () => {
                        const action = option.dataset.action;
                        closeModal();
                        if (action === 'pay') {
                            payJailFine(player);
                        } else if (action === 'card') {
                            useGetOutOfJailCard(player);
                        } else {
                            rollForJailEscape(player);
                        }
                    });
                });
            }, 100);
        }

        function useGetOutOfJailCard(player) {
            player.getOutOfJailCards--;
            player.inJail = false;
            player.jailTurns = 0;
            updatePlayersPanel();
            showMessage(`ðŸŽ« ${player.name} utilitza la Targeta Sortir de la PresÃ³ Gratis!`);
            addHistory('card', 'ðŸŽ«', `${player.name} utilitza una targeta per sortir de la presÃ³!`);
            document.getElementById('roll-dice').disabled = false;
        }

        function payJailFine(player) {
            const jailFine = gameConfig.jailFine;
            if (player.money < jailFine) {
                showMessage('No tens prou diners! Has de tirar els daus.');
                setTimeout(() => rollForJailEscape(player), 1000);
                return;
            }
            player.money -= jailFine;
            playPayMoney();
            player.inJail = false;
            player.jailTurns = 0;
            updatePlayersPanel();
            showMessage(`${player.name} paga ${jailFine}â‚¬ i surt de la preso!`);
            document.getElementById('roll-dice').disabled = false;
        }

        function rollForJailEscape(player) {
            const die1El = document.getElementById('die1');
            const die2El = document.getElementById('die2');
            const rollBtn = document.getElementById('roll-dice');

            rollBtn.disabled = true;
            die1El.classList.add('rolling');
            die2El.classList.add('rolling');

            // Play rolling sound
            playDiceRoll();

            let rolls = 0;
            const rollInterval = setInterval(() => {
                die1El.textContent = DICE_FACES[Math.floor(Math.random() * 6)];
                die2El.textContent = DICE_FACES[Math.floor(Math.random() * 6)];
                rolls++;

                if (rolls >= 10) {
                    clearInterval(rollInterval);

                    const dice1 = Math.floor(Math.random() * 6) + 1;
                    const dice2 = Math.floor(Math.random() * 6) + 1;

                    die1El.textContent = DICE_FACES[dice1 - 1];
                    die2El.textContent = DICE_FACES[dice2 - 1];
                    die1El.classList.remove('rolling');
                    die2El.classList.remove('rolling');

                    // Play dice landing sound
                    playDiceLand();

                    if (dice1 === dice2) {
                        // Doubles! Player escapes
                        player.inJail = false;
                        player.jailTurns = 0;
                        showMessage(`${player.name} treu dobles (${dice1}+${dice2}) i surt de la preso!`);
                        gameState.diceRolled = true;
                        setTimeout(() => movePlayer(dice1 + dice2), 500);
                    } else {
                        // No doubles
                        if (player.jailTurns >= 3) {
                            // Must pay after 3 turns
                            const jailFine = gameConfig.jailFine;
                            player.money -= jailFine;
                            playPayMoney(); // Coin sound
                            player.inJail = false;
                            player.jailTurns = 0;
                            showMessage(`${player.name} porta 3 torns, paga ${jailFine}â‚¬ i surt!`);
                            updatePlayersPanel();
                            gameState.diceRolled = true;
                            setTimeout(() => movePlayer(dice1 + dice2), 500);
                        } else {
                            showMessage(`${player.name} no treu dobles. Segueix a la preso.`);
                            endTurn();
                        }
                    }
                }
            }, 100);
        }

        // ==========================================
        // ANIMATION HELPERS
        // ==========================================

        function animateTokenMove(playerIndex) {
            // Only animate tokens on the main board, not in zoom view
            const boardTokens = document.querySelectorAll(`#board .token-on-board[data-player-index="${playerIndex}"]`);
            boardTokens.forEach(token => {
                token.classList.add('moving');
                setTimeout(() => token.classList.remove('moving'), 300);
            });
        }

        // ==========================================
        // INITIALIZATION
        // ==========================================

        document.addEventListener('DOMContentLoaded', () => {
            initSetup();
            // Check if saved game exists
            if (hasSavedGame()) {
                document.getElementById('btn-load').disabled = false;
            }
        });
    </script>
</body>
</html>
